diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 75533ec39a..443ced97f6 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -70,6 +70,7 @@ video tutorials.
  - Jason Francis
  - Gerald Franz
  - Mário Freitas
+ - Daijiro Fukuda
  - GeO4d
  - Marcus Geelnard
  - Gegy
@@ -98,6 +99,7 @@ video tutorials.
  - Warren Hu
  - Charles Huber
  - Brent Huisman
+ - Ryo Ichinose
  - illustris
  - InKryption
  - IntellectualKitty
@@ -116,6 +118,7 @@ video tutorials.
  - Cameron King
  - Peter Knut
  - Christoph Kubisch
+ - Yasutaka Kumei
  - Yuri Kunde Schlesner
  - Rokas Kupstys
  - Konstantin Käfer
@@ -269,6 +272,7 @@ video tutorials.
  - Andy Williams
  - Joel Winarske
  - Richard A. Wilkes
+ - xfangfang
  - Tatsuya Yatagawa
  - Ryogo Yoshimura
  - Lukas Zanner
diff --git a/README.md b/README.md
index cebe62bc58..60bd36018e 100644
--- a/README.md
+++ b/README.md
@@ -121,6 +121,28 @@ information on what to include when reporting a bug.
 
 ## Changelog
 
+ - Added `glfwSetPreeditCandidateCallback` function and
+   `GLFWpreeditcandidatefun` type for preedit candidates (#2130)
+ - Added `glfwGetPreeditCandidate` function to get a preeidt candidate text
+   (#2130)
+ - Added `GLFW_MANAGE_PREEDIT_CANDIDATE` init hint for displaying preedit
+   candidates on the application side (supported only on Windows currently)
+   (#2130)
+ - Added `glfwSetPreeditCallback` function and `GLFWpreeditfun` type for
+   preedit of input method (#2130)
+ - Added `glfwSetIMEStatusCallback` function and `GLFWimestatusfun` type for
+   status of input method (#2130)
+ - Added `glfwSetPreeditCursorRectangle` function to set the preedit cursor
+   area that is used to decide the position of the candidate window of input
+   method (#2130)
+ - Added `glfwGetPreeditCursorRectangle` function to get the preedit cursor
+   area (#2130)
+ - Added `glfwResetPreeditText` function to reset preedit of input method
+   (#2130)
+ - Added `GLFW_IME` input mode for `glfwGetInputMode` and `glfwSetInputMode`
+   (#2130)
+ - Added `GLFW_X11_ONTHESPOT` init hint for using on-the-spot input method
+   style on X11 (#2130)
  - Added `GLFW_PLATFORM` init hint for runtime platform selection (#1958)
  - Added `GLFW_ANY_PLATFORM`, `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,
    `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` and `GLFW_PLATFORM_NULL` symbols to
diff --git a/docs/input.dox b/docs/input.dox
index f57520bb4b..af13e80ba8 100644
--- a/docs/input.dox
+++ b/docs/input.dox
@@ -248,6 +248,260 @@ ignored.  This matches the behavior of the key callback, meaning the callback
 arguments can always be passed unmodified to this function.
 
 
+@section ime_support IME support
+
+IME (Input Method Editor/Engine) is used to input characters not mapped with
+physical keys.  It is popular among East Asian people.
+
+
+@subsection ime_style IME styles
+
+GLFW supports the following two styles of IME.
+
+ - On-the-spot
+ - Over-the-spot
+
+On-the-spot style is supported on Windows, macOS and Wayland.  On these platforms,
+applications need to draw preedit text directly in their UI by using the preedit
+callback (See [Preedit input](@ref input_preedit)).
+
+Over-the-spot style is supported on X11.  On this platform, the IME displays preedit
+text, and applications don't need to draw it.  So the preedit callback doesn't work
+on X11.
+
+In both styles, applications should manage the position of the candidate window.
+See [Candidate window](@ref candidate_window) for details.
+
+@note
+@x11 You can use on-the-spot style also on X11 by using @ref GLFW_X11_ONTHESPOT_hint.
+In this case, the preedit callback also works on X11.  However, on-the-spot style on
+X11 is unstable, so it is not recommended.
+
+
+@subsection input_preedit Preedit input
+
+When inputting text with IME, the text is temporarily inputted, then conversion
+and other processing are performed and finally committed.  The committed text is
+inputted in the same way as input without IME (See [Text input](@ref input_char)).
+
+This temporary input is called "preedit" or "pre-edit".
+
+On Windows, macOS and Wayland, that use on-the-spot sytle, applications need to
+take preedit information and draw it in their UI.
+
+You can register the preedit callback as follows.
+
+@code
+glfwSetPreeditCallback(window, preedit_callback);
+@endcode
+
+The callback receives the following information.
+
+@code
+void preedit_callback(GLFWwindow* window,
+                      int preedit_count,
+                      unsigned int* preedit_string,
+                      int block_count,
+                      int* block_sizes,
+                      int focused_block,
+                      int caret)
+{
+}
+@endcode
+
+"preedit_count" and "preedit_string" parameter represent the whole preedit text.
+Each character of the preedit string is a native endian UTF-32 like @ref input_char.
+
+If you want to type the text "寿司(sushi)", Usually the callback is called several
+times like the following sequence:
+
+-# key event: s
+-# preedit: [preedit_string: "ｓ", block_sizes: [1], focused_block: 0]
+-# key event: u
+-# preedit: [preedit_string: "す", block_sizes: [1], focused_block: 0]
+-# key event: s
+-# preedit: [preedit_string: "すｓ", block_sizes: [2], focused_block: 0]
+-# key event: h
+-# preedit: [preedit_string: "すｓｈ", block_sizes: [3], focused_block: 0]
+-# key event: i
+-# preedit: [preedit_string: "すし", block_sizes: [2], focused_block: 0]
+-# key event: ' '
+-# preedit: [preedit_string: "寿司", block_sizes: [2], focused_block: 0]
+-# char: '寿'
+-# char: '司'
+-# preedit: [preedit_string: "", block_sizes: [], focused_block: 0]
+
+If preedit text includes several semantic blocks, the callback returns several blocks:
+
+-# preedit: [preedit_string: "わたしはすしをたべます", block_sizes: [11], focused_block: 0]
+-# preedit: [preedit_string: "私は寿司を食べます", block_sizes: [2, 7], focused_block: 1]
+
+"block_sizes" is a list of the sizes of each block.  The above case, it contains the following
+blocks and the second block is focused.
+
+- 私は
+- [寿司を食べます]
+
+The application side should draw a focused block and unfocused blocks
+in different styles.
+
+You can use the "caret" parameter to draw the caret of the preedit text.
+The specification of this parameter depends on the specification of the input method.
+The following is an example on Win32.
+
+- "あいうえお|" (caret: 5)
+- key event: arrow-left
+- "あいうえ|お" (caret: 4)
+- ...
+- "|あいうえお" (caret: 0)
+
+
+@subsection candidate_window Candidate window
+
+The application has to manage the position of the candidate window that shows
+the preedit candidate list.  To do this, the application has to manage the area
+of the preedit text cursor by the following functions.  The IME displays the
+candidate window in the appropriate position based on the area of the preedit
+text cursor.
+
+@code
+glfwSetPreeditCursorRectangle(window, x, y, w, h);
+glfwGetPreeditCursorRectangle(window, &x, &y, &w, &h);
+@endcode
+
+
+@subsection ime_status IME status
+
+Sometimes, IME task needs to be interrupted by a user or an application.  There
+are several functions to support these situations.
+
+@note
+@x11 @wayland This feature is not supported.
+
+You can receive notification about IME status change(on/off) by using the following
+function:
+
+@code
+glfwSetIMEStatusCallback(window, imestatus_callback);
+@endcode
+
+The callback has a simple signature like this:
+
+@code
+void imestatus_callback(GLFWwindow* window)
+{
+}
+@endcode
+
+@anchor GLFW_IME
+You can get the current IME status by the following function:
+
+@code
+glfwGetInputMode(window, GLFW_IME);
+@endcode
+
+If you get GLFW_TRUE, it means the IME is on, and GLFW_FALSE means the IME is off.
+
+You can also change the IME status by the following function:
+
+@code
+glfwSetInputMode(window, GLFW_IME, GLFW_TRUE);
+glfwSetInputMode(window, GLFW_IME, GLFW_FALSE);
+@endcode
+
+You can use the following function to clear the current preedit.
+
+@code
+glfwResetPreeditText(window);
+@endcode
+
+
+@subsection ime_full_screen Full screen with IME
+
+To use IME in the full screen, you can use the
+[GLFW_SOFT_FULLSCREEN](@ref GLFW_SOFT_FULLSCREEN_hint) window hint.
+The default full screen of GLFW is exclusive and is not suitable for IME.
+Setting this window hint enables IME to display properly on the full screen.
+
+@code
+glfwWindowHint(GLFW_SOFT_FULLSCREEN, GLFW_TRUE);
+@endcode
+
+
+@subsection manage_preedit_candidate Manage preedit candidate
+
+By default, the IME manages the drawing of the preedit candidates, but
+sometimes you need to do that on the application side for some reason.  In such
+a case, you can use
+[GLFW_MANAGE_PREEDIT_CANDIDATE](@ref GLFW_MANAGE_PREEDIT_CANDIDATE_hint) init hint.
+By setting this to `GLFW_TRUE`, the IME stops managing the drawing of the
+candidates and the application needs to manage it by using the following
+functions.
+
+@note
+@win32 Only the OS currently supports this hint.
+
+You can register the candidate callback as follows.
+
+@code
+glfwSetPreeditCandidateCallback(window, candidate_callback);
+@endcode
+
+The callback receives the following information.
+
+@code
+void candidate_callback(GLFWwindow* window,
+                        int candidates_count,
+                        int selected_index,
+                        int page_start,
+                        int page_size)
+{
+}
+@endcode
+
+`candidates_count` is the number of total candidates.  `selected_index` is the
+index of the currently selected candidate.  Normally all candidates should not
+be displayed at once, but divided into pages.  You can use `page_start` and
+`page_size` to manage the pages.  `page_start` is the index of the first
+candidate on the current page.  `page_size` is the number of the candidates on
+the current page.
+
+You can get the text of the candidate on the specific index as follows.  Each
+character of the returned text is a native endian UTF-32.
+
+@code
+int text_count;
+unsigned int* text = glfwGetPreeditCandidate(window, index, &text_count);
+@endcode
+
+A sample code to get all candidate texts on the current page is as follows.
+
+@code
+void candidate_callback(GLFWwindow* window, int candidates_count,
+                        int selected_index, int page_start, int page_size)
+{
+    int i, j;
+    for (i = 0; i < page_size; ++i)
+    {
+        int index = i + page_start;
+        int text_count;
+        unsigned int* text = glfwGetPreeditCandidate(window, index, &text_count);
+        if (index == selected_index)
+            printf("> ");
+        for (j = 0; j < text_count; ++j)
+        {
+            char encoded[5] = "";
+            encode_utf8(encoded, text[j]); // Some kind of encoding process
+            printf("%s", encoded);
+        }
+        printf("\n");
+    }
+}
+
+glfwSetPreeditCandidateCallback(window, candidate_callback);
+@endcode
+
+
 @section input_mouse Mouse input
 
 Mouse input comes in many forms, including mouse motion, button presses and
diff --git a/docs/intro.dox b/docs/intro.dox
index 36ec0ef5bb..799bdab47b 100644
--- a/docs/intro.dox
+++ b/docs/intro.dox
@@ -119,6 +119,16 @@ The ANGLE platform type is specified via the `EGL_ANGLE_platform_angle`
 extension.  This extension is not used if this hint is
 `GLFW_ANGLE_PLATFORM_TYPE_NONE`, which is the default value.
 
+@anchor GLFW_MANAGE_PREEDIT_CANDIDATE_hint
+__GLFW_MANAGE_PREEDIT_CANDIDATE__ specifies whether to manage the preedit
+candidates on the application side.  Possible values are `GLFW_TRUE` and
+`GLFW_FALSE`.  The default is `GLFW_FALSE` and there is no need to manage
+the candidates on the application side.  When you need to do that on the
+application side for some reason, you can enable this hint.  Please see
+@ref ime_support for more information about IME support.
+
+@win32 Only the OS currently supports this hint.
+
 
 @subsubsection init_hints_osx macOS specific init hints
 
@@ -143,6 +153,14 @@ __GLFW_X11_XCB_VULKAN_SURFACE__ specifies whether to prefer the
 the `VK_KHR_xlib_surface` extension.  Possible values are `GLFW_TRUE` and
 `GLFW_FALSE`.  This is ignored on other platforms.
 
+@anchor GLFW_X11_ONTHESPOT_hint
+__GLFW_X11_ONTHESPOT__ specifies whether to use on-the-spot input method style.
+On X11 platform, over-the-spot style is used if this hint is `GLFW_FALSE`,
+which is the default value.  You can set `GLFW_TRUE` to use on-the-spot style
+as with other platforms.  However, on-the-spot style on X11 is unstable, so
+it is recommended not to use this hint in normal cases.  Possible values are
+`GLFW_TRUE` and `GLFW_FALSE`.  This is ignored on other platforms.  Please see
+@ref ime_support for more information about IME support.
 
 @subsubsection init_hints_wayland Wayland specific init hints
 
@@ -155,15 +173,17 @@ and `GLFW_WAYLAND_DISABLE_LIBDECOR`.  This is ignored on other platforms.
 
 @subsubsection init_hints_values Supported and default values
 
-Initialization hint              | Default value                   | Supported values
--------------------------------- | ------------------------------- | ----------------
-@ref GLFW_PLATFORM               | `GLFW_ANY_PLATFORM`             | `GLFW_ANY_PLATFORM`, `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`, `GLFW_PLATFORM_X11`, `GLFW_PLATFORM_WAYLAND` or `GLFW_PLATFORM_NULL`
-@ref GLFW_JOYSTICK_HAT_BUTTONS   | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
-@ref GLFW_ANGLE_PLATFORM_TYPE    | `GLFW_ANGLE_PLATFORM_TYPE_NONE` | `GLFW_ANGLE_PLATFORM_TYPE_NONE`, `GLFW_ANGLE_PLATFORM_TYPE_OPENGL`, `GLFW_ANGLE_PLATFORM_TYPE_OPENGLES`, `GLFW_ANGLE_PLATFORM_TYPE_D3D9`, `GLFW_ANGLE_PLATFORM_TYPE_D3D11`, `GLFW_ANGLE_PLATFORM_TYPE_VULKAN` or `GLFW_ANGLE_PLATFORM_TYPE_METAL`
-@ref GLFW_COCOA_CHDIR_RESOURCES  | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
-@ref GLFW_COCOA_MENUBAR          | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
-@ref GLFW_X11_XCB_VULKAN_SURFACE | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
-@ref GLFW_WAYLAND_LIBDECOR       | `GLFW_WAYLAND_PREFER_LIBDECOR`  | `GLFW_WAYLAND_PREFER_LIBDECOR` or `GLFW_WAYLAND_DISABLE_LIBDECOR`
+Initialization hint                | Default value                   | Supported values
+---------------------------------- | ------------------------------- | ----------------
+@ref GLFW_PLATFORM                 | `GLFW_ANY_PLATFORM`             | `GLFW_ANY_PLATFORM`, `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`, `GLFW_PLATFORM_X11`, `GLFW_PLATFORM_WAYLAND` or `GLFW_PLATFORM_NULL`
+@ref GLFW_JOYSTICK_HAT_BUTTONS     | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_ANGLE_PLATFORM_TYPE      | `GLFW_ANGLE_PLATFORM_TYPE_NONE` | `GLFW_ANGLE_PLATFORM_TYPE_NONE`, `GLFW_ANGLE_PLATFORM_TYPE_OPENGL`, `GLFW_ANGLE_PLATFORM_TYPE_OPENGLES`, `GLFW_ANGLE_PLATFORM_TYPE_D3D9`, `GLFW_ANGLE_PLATFORM_TYPE_D3D11`, `GLFW_ANGLE_PLATFORM_TYPE_VULKAN` or `GLFW_ANGLE_PLATFORM_TYPE_METAL`
+@ref GLFW_MANAGE_PREEDIT_CANDIDATE | `GLFW_FALSE`                    | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_COCOA_CHDIR_RESOURCES    | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_COCOA_MENUBAR            | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_X11_XCB_VULKAN_SURFACE   | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_X11_ONTHESPOT            | `GLFW_FALSE`                    | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_WAYLAND_LIBDECOR         | `GLFW_WAYLAND_PREFER_LIBDECOR`  | `GLFW_WAYLAND_PREFER_LIBDECOR` or `GLFW_WAYLAND_DISABLE_LIBDECOR`
 
 
 @subsection platform Runtime platform selection
diff --git a/docs/window.dox b/docs/window.dox
index 3cec6358a8..e241e8961e 100644
--- a/docs/window.dox
+++ b/docs/window.dox
@@ -239,6 +239,19 @@ __GLFW_FOCUS_ON_SHOW__ specifies whether the window will be given input
 focus when @ref glfwShowWindow is called. Possible values are `GLFW_TRUE` and
 `GLFW_FALSE`.
 
+@anchor GLFW_SOFT_FULLSCREEN_hint
+__GLFW_SOFT_FULLSCREEN__ specifies whether the full screen window will be
+_soft full screen_ or _hard full screen_.  Possible values are `GLFW_TRUE` and
+`GLFW_FALSE`.  The default is `GLFW_FALSE` and the full screen window will be
+_hard full screen_.
+
+_Hard full screen_ is exclusive screen and it is suitable for applications
+such as games.
+
+_Soft full screen_ is not exclusive screen and it is suitable for applications
+such as text-editors using Input Method Editor(Engine).
+See [Full screen with IME](@ref ime_full_screen) for details.
+
 @anchor GLFW_SCALE_TO_MONITOR
 __GLFW_SCALE_TO_MONITOR__ specified whether the window content area should be
 resized based on the [monitor content scale](@ref monitor_scale) of any monitor
@@ -543,6 +556,7 @@ GLFW_REFRESH_RATE             | `GLFW_DONT_CARE`            | 0 to `INT_MAX` or
 GLFW_STEREO                   | `GLFW_FALSE`                | `GLFW_TRUE` or `GLFW_FALSE`
 GLFW_SRGB_CAPABLE             | `GLFW_FALSE`                | `GLFW_TRUE` or `GLFW_FALSE`
 GLFW_DOUBLEBUFFER             | `GLFW_TRUE`                 | `GLFW_TRUE` or `GLFW_FALSE`
+GLFW_SOFT_FULLSCREEN          | `GLFW_FALSE`                | `GLFW_TRUE` or `GLFW_FALSE`
 GLFW_CLIENT_API               | `GLFW_OPENGL_API`           | `GLFW_OPENGL_API`, `GLFW_OPENGL_ES_API` or `GLFW_NO_API`
 GLFW_CONTEXT_CREATION_API     | `GLFW_NATIVE_CONTEXT_API`   | `GLFW_NATIVE_CONTEXT_API`, `GLFW_EGL_CONTEXT_API` or `GLFW_OSMESA_CONTEXT_API`
 GLFW_CONTEXT_VERSION_MAJOR    | 1                           | Any valid major version number of the chosen client API
diff --git a/include/GLFW/glfw3.h b/include/GLFW/glfw3.h
index eb98dafd49..dfd58ed0f1 100644
--- a/include/GLFW/glfw3.h
+++ b/include/GLFW/glfw3.h
@@ -320,18 +320,18 @@ extern "C" {
  */
 #define GLFW_FALSE                  0
 
-/*! @name Key and button actions
+/*! @name Key, button and touch actions
  *  @{ */
-/*! @brief The key or mouse button was released.
+/*! @brief The key or mouse button was released, or the touch ended.
  *
- *  The key or mouse button was released.
+ *  The key or mouse button was released, or the touch ended.
  *
  *  @ingroup input
  */
 #define GLFW_RELEASE                0
-/*! @brief The key or mouse button was pressed.
+/*! @brief The key or mouse button was pressed, or the touch started.
  *
- *  The key or mouse button was pressed.
+ *  The key or mouse button was pressed, or the touch started.
  *
  *  @ingroup input
  */
@@ -343,6 +343,13 @@ extern "C" {
  *  @ingroup input
  */
 #define GLFW_REPEAT                 2
+/*! @brief The touch was moved.
+ *
+ *  The touch was moved.
+ *
+ *  @ingroup input
+ */
+#define GLFW_MOVE                   3
 /*! @} */
 
 /*! @defgroup hat_state Joystick hat states
@@ -941,6 +948,12 @@ extern "C" {
  */
 #define GLFW_POSITION_Y             0x0002000F
 
+/*! @brief Soft fullscreen window hint
+ *
+ *  Soft fullscreen [window hint](@ref GLFW_SOFT_FULLSCREEN_hint).
+ */
+#define GLFW_SOFT_FULLSCREEN  0x00020010
+
 /*! @brief Framebuffer bit depth hint.
  *
  *  Framebuffer bit depth [hint](@ref GLFW_RED_BITS).
@@ -1144,6 +1157,8 @@ extern "C" {
 #define GLFW_STICKY_MOUSE_BUTTONS   0x00033003
 #define GLFW_LOCK_KEY_MODS          0x00033004
 #define GLFW_RAW_MOUSE_MOTION       0x00033005
+#define GLFW_IME                    0x00033006
+#define GLFW_TOUCH                  0x00033007
 
 #define GLFW_CURSOR_NORMAL          0x00034001
 #define GLFW_CURSOR_HIDDEN          0x00034002
@@ -1297,6 +1312,11 @@ extern "C" {
  *  Platform selection [init hint](@ref GLFW_PLATFORM).
  */
 #define GLFW_PLATFORM               0x00050003
+/*! @brief Preedit candidate init hint.
+ *
+ *  Preedit candidate [init hint](@ref GLFW_MANAGE_PREEDIT_CANDIDATE_hint).
+ */
+#define GLFW_MANAGE_PREEDIT_CANDIDATE 0x00050004
 /*! @brief macOS specific init hint.
  *
  *  macOS specific [init hint](@ref GLFW_COCOA_CHDIR_RESOURCES_hint).
@@ -1312,6 +1332,11 @@ extern "C" {
  *  X11 specific [init hint](@ref GLFW_X11_XCB_VULKAN_SURFACE_hint).
  */
 #define GLFW_X11_XCB_VULKAN_SURFACE 0x00052001
+/*! @brief X11 specific init hint.
+ *
+ *  X11 specific [init hint](@ref GLFW_X11_ONTHESPOT_hint).
+ */
+#define GLFW_X11_ONTHESPOT          0x00052002
 /*! @brief Wayland specific init hint.
  *
  *  Wayland specific [init hint](@ref GLFW_WAYLAND_LIBDECOR_hint).
@@ -1908,6 +1933,67 @@ typedef void (* GLFWcharfun)(GLFWwindow* window, unsigned int codepoint);
  */
 typedef void (* GLFWcharmodsfun)(GLFWwindow* window, unsigned int codepoint, int mods);
 
+/*! @brief The function pointer type for preedit callbacks.
+ *
+ *  This is the function pointer type for preedit callback functions.
+ *
+ *  @param[in] window The window that received the event.
+ *  @param[in] preedit_count Preedit string count.
+ *  @param[in] preedit_string Preedit string.
+ *  @param[in] block_count Attributed block count.
+ *  @param[in] block_sizes List of attributed block size.
+ *  @param[in] focused_block Focused block index.
+ *  @param[in] caret Caret position.
+ *
+ *  @sa @ref ime_support
+ *  @sa glfwSetPreeditCallback
+ *
+ *  @ingroup input
+ */
+typedef void (* GLFWpreeditfun)(GLFWwindow* window,
+                                int preedit_count,
+                                unsigned int* preedit_string,
+                                int block_count,
+                                int* block_sizes,
+                                int focused_block,
+                                int caret);
+
+/*! @brief The function pointer type for IME status change callbacks.
+ *
+ *  This is the function pointer type for IME status change callback functions.
+ *
+ *  @param[in] window The window that received the event.
+ *
+ *  @sa @ref ime_support
+ *  @sa glfwSetIMEStatusCallback
+ *
+ *  @ingroup monitor
+ */
+typedef void (* GLFWimestatusfun)(GLFWwindow* window);
+
+/*! @brief The function pointer type for preedit candidate callbacks.
+ *
+ *  This is the function pointer type for preedit candidate callback functions.
+ *  Use @ref glfwGetPreeditCandidate to get the candidate text for a specific index.
+ *
+ *  @param[in] window The window that received the event.
+ *  @param[in] candidates_count Candidates count.
+ *  @param[in] selected_index.Index of selected candidate.
+ *  @param[in] page_start Start index of candidate currently displayed.
+ *  @param[in] page_size Count of candidates currently displayed.
+ *
+ *  @sa @ref ime_support
+ *  @sa @ref glfwSetPreeditCandidateCallback
+ *  @sa @ref glfwGetPreeditCandidate
+ *
+ *  @ingroup input
+ */
+typedef void (* GLFWpreeditcandidatefun)(GLFWwindow* window,
+                                         int candidates_count,
+                                         int selected_index,
+                                         int page_start,
+                                         int page_size);
+
 /*! @brief The function pointer type for path drop callbacks.
  *
  *  This is the function pointer type for path drop callbacks.  A path drop
@@ -1932,6 +2018,26 @@ typedef void (* GLFWcharmodsfun)(GLFWwindow* window, unsigned int codepoint, int
  */
 typedef void (* GLFWdropfun)(GLFWwindow* window, int path_count, const char* paths[]);
 
+/*! @brief The function pointer type for touch callbacks.
+ *
+ *  This is the function pointer type for touch callbacks.
+ *  A touch callback function has the following signature:
+ *  @code
+ *  void function_name(GLFWwindow* window, int touch, int action, double xpos, double ypos)
+ *  @endcode
+ *
+ *  @param[in] window The window that received the event.
+ *  @param[in] touch The touch that triggered the event.
+ *  @param[in] action One of @ref GLFW_PRESS, @ref GLFW_MOVE or @ref GLFW_RELEASE.
+ *  @param[in] xpos The new x-coordinate of the touch.
+ *  @param[in] ypos The new y-coordinate of the touch.
+ *
+ *  @sa @ref glfwSetTouchCallback
+ *
+ *  @ingroup input
+ */
+typedef void (* GLFWtouchfun)(GLFWwindow*,int,int,double,double);
+
 /*! @brief The function pointer type for monitor configuration callbacks.
  *
  *  This is the function pointer type for monitor configuration callbacks.
@@ -4556,13 +4662,13 @@ GLFWAPI void glfwPostEmptyEvent(void);
  *
  *  This function returns the value of an input option for the specified window.
  *  The mode must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,
- *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or
- *  @ref GLFW_RAW_MOUSE_MOTION.
+ *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS,
+ *  @ref GLFW_RAW_MOUSE_MOTION, @ref GLFW_IME or @ref GLFW_TOUCH.
  *
  *  @param[in] window The window to query.
  *  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
- *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
- *  `GLFW_RAW_MOUSE_MOTION`.
+ *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS`, `GLFW_RAW_MOUSE_MOTION`,
+ *  `GLFW_IME`, or `GLFW_TOUCH`..
  *
  *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref
  *  GLFW_INVALID_ENUM.
@@ -4581,8 +4687,8 @@ GLFWAPI int glfwGetInputMode(GLFWwindow* window, int mode);
  *
  *  This function sets an input mode option for the specified window.  The mode
  *  must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,
- *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or
- *  @ref GLFW_RAW_MOUSE_MOTION.
+ *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS,
+ *  @ref GLFW_RAW_MOUSE_MOTION, @ref GLFW_IME or @ref GLFW_TOUCH.
  *
  *  If the mode is `GLFW_CURSOR`, the value must be one of the following cursor
  *  modes:
@@ -4622,10 +4728,18 @@ GLFWAPI int glfwGetInputMode(GLFWwindow* window, int mode);
  *  attempting to set this will emit @ref GLFW_FEATURE_UNAVAILABLE.  Call @ref
  *  glfwRawMouseMotionSupported to check for support.
  *
+ *  If the mode is `GLFW_IME`, the value must be either `GLFW_TRUE` to turn on
+ *  IME, or `GLFW_FALSE` to turn off it.
+ *
+ *  If the mode is `GLFW_TOUCH`, the value must be either `GLFW_TRUE` to enable 
+ *  touch input, or `GLFW_FALSE` to disable it. If touch input is not supported,
+ *  attempting to set this will emit @ref GLFW_FEATURE_UNAVAILABLE.  Call @ref
+ *  glfwTouchInputSupported to check for support.
+ *
  *  @param[in] window The window whose input mode to set.
  *  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
- *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
- *  `GLFW_RAW_MOUSE_MOTION`.
+ *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS`,
+ *  `GLFW_RAW_MOUSE_MOTION`, `GLFW_IME` or `GLFW_TOUCH`.
  *  @param[in] value The new value of the specified input mode.
  *
  *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref
@@ -4671,6 +4785,26 @@ GLFWAPI void glfwSetInputMode(GLFWwindow* window, int mode, int value);
  */
 GLFWAPI int glfwRawMouseMotionSupported(void);
 
+/*! @brief Returns whether touch input is supported.
+ *
+ *  This function returns whether touch input is supported on the current
+ *  system.  This status does not change after GLFW has been initialized so you
+ *  only need to check this once.  If you attempt to enable touch input on
+ *  a system that does not support it, @ref GLFW_PLATFORM_ERROR will be emitted.
+ *
+ *  @return `GLFW_TRUE` if touch input is supported on the current machine,
+ *  or `GLFW_FALSE` otherwise.
+ *
+ *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
+ *
+ *  @thread_safety This function must only be called from the main thread.
+ *
+ *  @sa @ref glfwSetInputMode
+ *
+ *  @ingroup input
+ */
+GLFWAPI int glfwTouchInputSupported(void);
+
 /*! @brief Returns the layout-specific name of the specified printable key.
  *
  *  This function returns the name of the specified printable key, encoded as
@@ -5052,6 +5186,100 @@ GLFWAPI void glfwDestroyCursor(GLFWcursor* cursor);
  */
 GLFWAPI void glfwSetCursor(GLFWwindow* window, GLFWcursor* cursor);
 
+/*! @brief Retrieves the area of the preedit text cursor.
+ *
+ *  This area is used to decide the position of the candidate window.
+ *  The cursor position is relative to the window.
+ *
+ *  @param[in] window The window to set the preedit text cursor for.
+ *  @param[out] x The preedit text cursor x position (relative position from window coordinates).
+ *  @param[out] y The preedit text cursor y position (relative position from window coordinates).
+ *  @param[out] w The preedit text cursor width.
+ *  @param[out] h The preedit text cursor height.
+ *
+ *  @par Thread Safety
+ *  This function may only be called from the main thread.
+ *
+ *  @sa @ref ime_support
+ *
+ *  @since Added in GLFW 3.X.
+ *
+ *  @ingroup input
+ */
+GLFWAPI void glfwGetPreeditCursorRectangle(GLFWwindow* window, int* x, int* y, int* w, int* h);
+
+/*! @brief Sets the area of the preedit text cursor.
+ *
+ *  This area is used to decide the position of the candidate window.
+ *  The cursor position is relative to the window.
+ *
+ *  @param[in] window The window to set the text cursor for.
+ *  @param[in] x The preedit text cursor x position (relative position from window coordinates).
+ *  @param[in] y The preedit text cursor y position (relative position from window coordinates).
+ *  @param[in] w The preedit text cursor width.
+ *  @param[in] h The preedit text cursor height.
+ *
+ *  @par Thread Safety
+ *  This function may only be called from the main thread.
+ *
+ *  @sa @ref ime_support
+ *
+ *  @since Added in GLFW 3.X.
+ *
+ *  @ingroup input
+ */
+GLFWAPI void glfwSetPreeditCursorRectangle(GLFWwindow* window, int x, int y, int w, int h);
+
+/*! @brief Resets IME input status.
+ *
+ *  This function resets IME's preedit text.
+ *
+ *  @param[in] window The window.
+ *
+ *  @remark @x11 Since over-the-spot style is used by default, you don't need
+ *  to use this function.
+ *
+ *  @remark @wayland This function is currently not supported.
+ *
+ *  @par Thread Safety
+ *  This function may only be called from the main thread.
+ *
+ *  @sa @ref ime_support
+ *
+ *  @since Added in GLFW 3.X.
+ *
+ *  @ingroup input
+ */
+GLFWAPI void glfwResetPreeditText(GLFWwindow* window);
+
+/*! @brief Returns the preedit candidate.
+ *
+ *  This function returns the text and the text-count of the preedit candidate.
+ *
+ *  By default, the IME manages the preedit candidates, so there is no need to
+ *  use this function.  See @ref glfwSetPreeditCandidateCallback and
+ *  [GLFW_MANAGE_PREEDIT_CANDIDATE](@ref GLFW_MANAGE_PREEDIT_CANDIDATE_hint) for details.
+ *
+ *  @param[in] window The window.
+ *  @param[in] index The index of the candidate.
+ *  @param[out] textCount The text-count of the candidate.
+ *  @return The text of the candidate as Unicode code points.
+ *
+ *  @remark @macos @x11 @wayland Don't support this function.
+ *
+ *  @par Thread Safety
+ *  This function may only be called from the main thread.
+ *
+ *  @sa @ref ime_support
+ *  @sa @ref glfwSetPreeditCandidateCallback
+ *  @sa [GLFW_MANAGE_PREEDIT_CANDIDATE](@ref GLFW_MANAGE_PREEDIT_CANDIDATE_hint)
+ *
+ *  @since Added in GLFW 3.X.
+ *
+ *  @ingroup input
+ */
+GLFWAPI unsigned int* glfwGetPreeditCandidate(GLFWwindow* window, int index, int* textCount);
+
 /*! @brief Sets the key callback.
  *
  *  This function sets the key callback of the specified window, which is called
@@ -5187,6 +5415,124 @@ GLFWAPI GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun callback
  */
 GLFWAPI GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow* window, GLFWcharmodsfun callback);
 
+/*! @brief Sets the preedit callback.
+ *
+ *  This function sets the preedit callback of the specified
+ *  window, which is called when an IME is processing text before committed.
+ *
+ *  Callback receives relative position of input cursor inside preedit text and
+ *  attributed text blocks.  This callback is used for on-the-spot text editing
+ *  with IME.
+ *
+ *  @param[in] window The window whose callback to set.
+ *  @param[in] cbfun The new callback, or `NULL` to remove the currently set
+ *  callback.
+ *  @return The previously set callback, or `NULL` if no callback was set or an
+ *  error occurred.
+ *
+ *  @callback_signature
+ *  @code
+ *  void function_name(GLFWwindow* window,
+                       int preedit_count,
+                       unsigned int* preedit_string,
+                       int block_count,
+                       int* block_sizes,
+                       int focused_block,
+                       int caret)
+ *  @endcode
+ *  For more information about the callback parameters, see the
+ *  [function pointer type](@ref GLFWpreeditfun).
+ *
+ *  @remark @x11 Since over-the-spot style is used by default, you don't need
+ *  to use this function.
+ *
+ *  @par Thread Safety
+ *  This function may only be called from the main thread.
+ *
+ *  @sa @ref ime_support
+ *
+ *  @since Added in GLFW 3.X
+ *
+ *  @ingroup input
+ */
+GLFWAPI GLFWpreeditfun glfwSetPreeditCallback(GLFWwindow* window, GLFWpreeditfun cbfun);
+
+/*! @brief Sets the IME status change callback.
+ *
+ *  This function sets the IME status callback of the specified
+ *  window, which is called when an IME is switched on and off.
+ *
+ *  @param[in] window The window whose callback to set.
+ *  @param[in] cbfun The new callback, or `NULL` to remove the currently set
+ *  callback.
+ *  @return The previously set callback, or `NULL` if no callback was set or an
+ *  error occurred.
+ *
+ *  @callback_signature
+ *  @code
+ *  void function_name(GLFWwindow* window)
+ *  @endcode
+ *  For more information about the callback parameters, see the
+ *  [function pointer type](@ref GLFWimestatusfun).
+ *
+ *  @remark @x11 @wayland Don't support this function.  The callback is not called.
+ *
+ *  @par Thread Safety
+ *  This function may only be called from the main thread.
+ *
+ *  @sa @ref ime_support
+ *
+ *  @since Added in GLFW 3.X
+ *
+ *  @ingroup input
+ */
+GLFWAPI GLFWimestatusfun glfwSetIMEStatusCallback(GLFWwindow* window, GLFWimestatusfun cbfun);
+
+/*! @brief Sets the preedit candidate change callback.
+ *
+ *  This function sets the preedit candidate callback of the specified
+ *  window, which is called when the candidates are updated and can be used
+ *  to display them by the application side.
+ *
+ *  By default, this callback is not called because the IME displays the
+ *  candidates and there is nothing to do on the application side.  Only when
+ *  the application side needs to use this to manage the displaying of 
+ *  IME candidates, you can set
+ *  [GLFW_MANAGE_PREEDIT_CANDIDATE](@ref GLFW_MANAGE_PREEDIT_CANDIDATE_hint) init hint
+ *  and stop the IME from managing it.
+ * 
+ *  @param[in] window The window whose callback to set.
+ *  @param[in] cbfun The new callback, or `NULL` to remove the currently set
+ *  callback.
+ *  @return The previously set callback, or `NULL` if no callback was set or an
+ *  error occurred.
+ *
+ *  @callback_signature
+ *  @code
+ *  void function_name(GLFWwindow* window,
+                       int candidates_count,
+                       int selected_index,
+                       int page_start,
+                       int page_size)
+ *  @endcode
+ *  For more information about the callback parameters, see the
+ *  [function pointer type](@ref GLFWpreeditcandidatefun).
+ *
+ *  @remark @macos @x11 @wayland Don't support this function.  The callback is
+ *  not called.
+ *
+ *  @par Thread Safety
+ *  This function may only be called from the main thread.
+ *
+ *  @sa @ref ime_support
+ *  @sa [GLFW_MANAGE_PREEDIT_CANDIDATE](@ref GLFW_MANAGE_PREEDIT_CANDIDATE_hint)
+ *
+ *  @since Added in GLFW 3.X
+ *
+ *  @ingroup input
+ */
+GLFWAPI GLFWpreeditcandidatefun glfwSetPreeditCandidateCallback(GLFWwindow* window, GLFWpreeditcandidatefun cbfun);
+
 /*! @brief Sets the mouse button callback.
  *
  *  This function sets the mouse button callback of the specified window, which
@@ -5358,6 +5704,21 @@ GLFWAPI GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun ca
  */
 GLFWAPI GLFWdropfun glfwSetDropCallback(GLFWwindow* window, GLFWdropfun callback);
 
+/*! @brief Sets the touch callback.
+ *
+ *  This function sets the touch callback, which is called when a touch is
+ *  started, ended or moved.
+ *
+ *  @param[in] window The window whose callback to set.
+ *  @param[in] callback The new touch callback, or `NULL` to remove the currently
+ *  set callback.
+ *  @return The previously set callback, or `NULL` if no callback was set or an
+ *  error occurred.
+ *
+ *  @ingroup input
+ */
+GLFWAPI GLFWtouchfun glfwSetTouchCallback(GLFWwindow* window, GLFWtouchfun callback);
+
 /*! @brief Returns whether the specified joystick is present.
  *
  *  This function returns whether the specified joystick is present.
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 7b84ecf2e2..46a8567ee5 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -113,6 +113,12 @@ if (GLFW_BUILD_WAYLAND)
     wayland_generate(
         "${WAYLAND_PROTOCOLS_BASE}/unstable/idle-inhibit/idle-inhibit-unstable-v1.xml"
         "${GLFW_BINARY_DIR}/src/wayland-idle-inhibit-unstable-v1-client-protocol")
+    wayland_generate(
+        "${WAYLAND_PROTOCOLS_BASE}/unstable/text-input/text-input-unstable-v1.xml"
+        "${GLFW_BINARY_DIR}/src/wayland-text-input-unstable-v1-client-protocol")
+    wayland_generate(
+        "${WAYLAND_PROTOCOLS_BASE}/unstable/text-input/text-input-unstable-v3.xml"
+        "${GLFW_BINARY_DIR}/src/wayland-text-input-unstable-v3-client-protocol")
 endif()
 
 if (WIN32 AND GLFW_BUILD_SHARED_LIBRARY)
diff --git a/src/cocoa_init.m b/src/cocoa_init.m
index b3831df15e..f290d3ba7c 100644
--- a/src/cocoa_init.m
+++ b/src/cocoa_init.m
@@ -351,22 +351,70 @@ static GLFWbool initializeTIS(void)
         return GLFW_FALSE;
     }
 
+    CFStringRef* kCategoryKeyboardInputSource =
+        CFBundleGetDataPointerForName(_glfw.ns.tis.bundle,
+                                      CFSTR("kTISCategoryKeyboardInputSource"));
+    CFStringRef* kPropertyInputSourceCategory =
+        CFBundleGetDataPointerForName(_glfw.ns.tis.bundle,
+                                      CFSTR("kTISPropertyInputSourceCategory"));
+    CFStringRef* kPropertyInputSourceID =
+        CFBundleGetDataPointerForName(_glfw.ns.tis.bundle,
+                                      CFSTR("kTISPropertyInputSourceID"));
+    CFStringRef* kPropertyInputSourceIsSelectCapable =
+        CFBundleGetDataPointerForName(_glfw.ns.tis.bundle,
+                                      CFSTR("kTISPropertyInputSourceIsSelectCapable"));
+    CFStringRef* kPropertyInputSourceType =
+        CFBundleGetDataPointerForName(_glfw.ns.tis.bundle,
+                                      CFSTR("kTISPropertyInputSourceType"));
     CFStringRef* kPropertyUnicodeKeyLayoutData =
         CFBundleGetDataPointerForName(_glfw.ns.tis.bundle,
                                       CFSTR("kTISPropertyUnicodeKeyLayoutData"));
+    CFStringRef* kTypeKeyboardInputMethodModeEnabled =
+        CFBundleGetDataPointerForName(_glfw.ns.tis.bundle,
+                                      CFSTR("kTISTypeKeyboardInputMethodModeEnabled"));
+    _glfw.ns.tis.CopyCurrentASCIICapableKeyboardInputSource =
+        CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
+                                          CFSTR("TISCopyCurrentASCIICapableKeyboardInputSource"));
+    _glfw.ns.tis.CopyCurrentKeyboardInputSource =
+        CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
+                                          CFSTR("TISCopyCurrentKeyboardInputSource"));
     _glfw.ns.tis.CopyCurrentKeyboardLayoutInputSource =
         CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
                                           CFSTR("TISCopyCurrentKeyboardLayoutInputSource"));
+    _glfw.ns.tis.CopyInputSourceForLanguage =
+        CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
+                                          CFSTR("TISCopyInputSourceForLanguage"));
+    _glfw.ns.tis.CreateASCIICapableInputSourceList =
+        CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
+                                          CFSTR("TISCreateASCIICapableInputSourceList"));
+    _glfw.ns.tis.CreateInputSourceList =
+        CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
+                                          CFSTR("TISCreateInputSourceList"));
     _glfw.ns.tis.GetInputSourceProperty =
         CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
                                           CFSTR("TISGetInputSourceProperty"));
+    _glfw.ns.tis.SelectInputSource =
+        CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
+                                          CFSTR("TISSelectInputSource"));
     _glfw.ns.tis.GetKbdType =
         CFBundleGetFunctionPointerForName(_glfw.ns.tis.bundle,
                                           CFSTR("LMGetKbdType"));
 
-    if (!kPropertyUnicodeKeyLayoutData ||
+    if (!kCategoryKeyboardInputSource||
+        !kPropertyInputSourceCategory ||
+        !kPropertyInputSourceID ||
+        !kPropertyInputSourceIsSelectCapable||
+        !kPropertyInputSourceType||
+        !kPropertyUnicodeKeyLayoutData ||
+        !kTypeKeyboardInputMethodModeEnabled ||
+        !TISCopyCurrentASCIICapableKeyboardInputSource ||
+        !TISCopyCurrentKeyboardInputSource ||
         !TISCopyCurrentKeyboardLayoutInputSource ||
+        !TISCopyInputSourceForLanguage ||
+        !TISCreateASCIICapableInputSourceList ||
+        !TISCreateInputSourceList ||
         !TISGetInputSourceProperty ||
+        !TISSelectInputSource ||
         !LMGetKbdType)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
@@ -374,8 +422,20 @@ static GLFWbool initializeTIS(void)
         return GLFW_FALSE;
     }
 
+    _glfw.ns.tis.kCategoryKeyboardInputSource =
+        *kCategoryKeyboardInputSource;
+    _glfw.ns.tis.kPropertyInputSourceCategory =
+        *kPropertyInputSourceCategory;
+    _glfw.ns.tis.kPropertyInputSourceID =
+        *kPropertyInputSourceID;
+    _glfw.ns.tis.kPropertyInputSourceIsSelectCapable =
+        *kPropertyInputSourceIsSelectCapable;
+    _glfw.ns.tis.kPropertyInputSourceType =
+        *kPropertyInputSourceType;
     _glfw.ns.tis.kPropertyUnicodeKeyLayoutData =
         *kPropertyUnicodeKeyLayoutData;
+    _glfw.ns.tis.kTypeKeyboardInputMethodModeEnabled =
+        *kTypeKeyboardInputMethodModeEnabled;
 
     return updateUnicodeData();
 }
@@ -511,6 +571,12 @@ GLFWbool _glfwConnectCocoa(int platformID, _GLFWplatform* platform)
         _glfwGetKeyScancodeCocoa,
         _glfwSetClipboardStringCocoa,
         _glfwGetClipboardStringCocoa,
+        _glfwUpdatePreeditCursorRectangleCocoa,
+        _glfwResetPreeditTextCocoa,
+        _glfwSetIMEStatusCocoa,
+        _glfwGetIMEStatusCocoa,
+        _glfwSetTouchInputCocoa,
+        _glfwTouchInputSupportedCocoa,
         _glfwInitJoysticksCocoa,
         _glfwTerminateJoysticksCocoa,
         _glfwPollJoystickCocoa,
diff --git a/src/cocoa_platform.h b/src/cocoa_platform.h
index 9f7d191db3..c5c1dddb63 100644
--- a/src/cocoa_platform.h
+++ b/src/cocoa_platform.h
@@ -109,11 +109,29 @@ typedef VkResult (APIENTRY *PFN_vkCreateMetalSurfaceEXT)(VkInstance,const VkMeta
 #define GLFW_NSGL_LIBRARY_CONTEXT_STATE _GLFWlibraryNSGL nsgl;
 
 // HIToolbox.framework pointer typedefs
+#define kTISCategoryKeyboardInputSource _glfw.ns.tis.kCategoryKeyboardInputSource
+#define kTISPropertyInputSourceCategory _glfw.ns.tis.kPropertyInputSourceCategory
+#define kTISPropertyInputSourceID _glfw.ns.tis.kPropertyInputSourceID
+#define kTISPropertyInputSourceIsSelectCapable _glfw.ns.tis.kPropertyInputSourceIsSelectCapable
+#define kTISPropertyInputSourceType _glfw.ns.tis.kPropertyInputSourceType
 #define kTISPropertyUnicodeKeyLayoutData _glfw.ns.tis.kPropertyUnicodeKeyLayoutData
+#define kTISTypeKeyboardInputMethodModeEnabled _glfw.ns.tis.kTypeKeyboardInputMethodModeEnabled
+typedef TISInputSourceRef (*PFN_TISCopyCurrentASCIICapableKeyboardInputSource)(void);
+#define TISCopyCurrentASCIICapableKeyboardInputSource _glfw.ns.tis.CopyCurrentASCIICapableKeyboardInputSource
+typedef TISInputSourceRef (*PFN_TISCopyCurrentKeyboardInputSource)(void);
+#define TISCopyCurrentKeyboardInputSource _glfw.ns.tis.CopyCurrentKeyboardInputSource
 typedef TISInputSourceRef (*PFN_TISCopyCurrentKeyboardLayoutInputSource)(void);
 #define TISCopyCurrentKeyboardLayoutInputSource _glfw.ns.tis.CopyCurrentKeyboardLayoutInputSource
+typedef TISInputSourceRef (*PFN_TISCopyInputSourceForLanguage)(CFStringRef);
+#define TISCopyInputSourceForLanguage _glfw.ns.tis.CopyInputSourceForLanguage
+typedef CFArrayRef (*PFN_TISCreateASCIICapableInputSourceList)(void);
+#define TISCreateASCIICapableInputSourceList _glfw.ns.tis.CreateASCIICapableInputSourceList
+typedef CFArrayRef (*PEN_TISCreateInputSourceList)(CFDictionaryRef,Boolean);
+#define TISCreateInputSourceList _glfw.ns.tis.CreateInputSourceList
 typedef void* (*PFN_TISGetInputSourceProperty)(TISInputSourceRef,CFStringRef);
 #define TISGetInputSourceProperty _glfw.ns.tis.GetInputSourceProperty
+typedef OSStatus (*PFN_TISSelectInputSource)(TISInputSourceRef);
+#define TISSelectInputSource _glfw.ns.tis.SelectInputSource
 typedef UInt8 (*PFN_LMGetKbdType)(void);
 #define LMGetKbdType _glfw.ns.tis.GetKbdType
 
@@ -184,10 +202,22 @@ typedef struct _GLFWlibraryNS
 
     struct {
         CFBundleRef     bundle;
+        PFN_TISCopyCurrentASCIICapableKeyboardInputSource CopyCurrentASCIICapableKeyboardInputSource;
+        PFN_TISCopyCurrentKeyboardInputSource CopyCurrentKeyboardInputSource;
         PFN_TISCopyCurrentKeyboardLayoutInputSource CopyCurrentKeyboardLayoutInputSource;
+        PFN_TISCopyInputSourceForLanguage CopyInputSourceForLanguage;
+        PFN_TISCreateASCIICapableInputSourceList CreateASCIICapableInputSourceList;
+        PEN_TISCreateInputSourceList CreateInputSourceList;
         PFN_TISGetInputSourceProperty GetInputSourceProperty;
+        PFN_TISSelectInputSource SelectInputSource;
         PFN_LMGetKbdType GetKbdType;
+        CFStringRef     kCategoryKeyboardInputSource;
+        CFStringRef     kPropertyInputSourceCategory;
+        CFStringRef     kPropertyInputSourceID;
+        CFStringRef     kPropertyInputSourceIsSelectCapable;
+        CFStringRef     kPropertyInputSourceType;
         CFStringRef     kPropertyUnicodeKeyLayoutData;
+        CFStringRef     kTypeKeyboardInputMethodModeEnabled;
     } tis;
 } _GLFWlibraryNS;
 
@@ -251,6 +281,9 @@ void _glfwSetWindowMousePassthroughCocoa(_GLFWwindow* window, GLFWbool enabled);
 void _glfwSetRawMouseMotionCocoa(_GLFWwindow *window, GLFWbool enabled);
 GLFWbool _glfwRawMouseMotionSupportedCocoa(void);
 
+void _glfwSetTouchInputCocoa(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwTouchInputSupportedCocoa(void);
+
 void _glfwPollEventsCocoa(void);
 void _glfwWaitEventsCocoa(void);
 void _glfwWaitEventsTimeoutCocoa(double timeout);
@@ -268,6 +301,11 @@ void _glfwSetCursorCocoa(_GLFWwindow* window, _GLFWcursor* cursor);
 void _glfwSetClipboardStringCocoa(const char* string);
 const char* _glfwGetClipboardStringCocoa(void);
 
+void _glfwUpdatePreeditCursorRectangleCocoa(_GLFWwindow* window);
+void _glfwResetPreeditTextCocoa(_GLFWwindow* window);
+void _glfwSetIMEStatusCocoa(_GLFWwindow* window, int active);
+int _glfwGetIMEStatusCocoa(_GLFWwindow* window);
+
 EGLenum _glfwGetEGLPlatformCocoa(EGLint** attribs);
 EGLNativeDisplayType _glfwGetEGLNativeDisplayCocoa(void);
 EGLNativeWindowType _glfwGetEGLNativeWindowCocoa(_GLFWwindow* window);
diff --git a/src/cocoa_window.m b/src/cocoa_window.m
index 9d79494053..a87eb31a0b 100644
--- a/src/cocoa_window.m
+++ b/src/cocoa_window.m
@@ -322,6 +322,11 @@ static const NSRange kEmptyRange = { NSNotFound, 0 };
 #endif
 }
 
+- (void)imeStatusChangeNotified:(NSNotification *)notification
+{
+    _glfwInputIMEStatus(window);
+}
+
 @end
 
 
@@ -566,7 +571,8 @@ static const NSRange kEmptyRange = { NSNotFound, 0 };
     const int key = translateKey([event keyCode]);
     const int mods = translateFlags([event modifierFlags]);
 
-    _glfwInputKey(window, key, [event keyCode], GLFW_PRESS, mods);
+    if (![self hasMarkedText])
+        _glfwInputKey(window, key, [event keyCode], GLFW_PRESS, mods);
 
     [self interpretKeyEvents:@[event]];
 }
@@ -659,7 +665,7 @@ static const NSRange kEmptyRange = { NSNotFound, 0 };
 - (NSRange)markedRange
 {
     if ([markedText length] > 0)
-        return NSMakeRange(0, [markedText length] - 1);
+        return NSMakeRange(0, [markedText length]);
     else
         return kEmptyRange;
 }
@@ -678,11 +684,95 @@ static const NSRange kEmptyRange = { NSNotFound, 0 };
         markedText = [[NSMutableAttributedString alloc] initWithAttributedString:string];
     else
         markedText = [[NSMutableAttributedString alloc] initWithString:string];
+
+    NSString* markedTextString = markedText.string;
+
+    NSUInteger textLen = [markedTextString length];
+    _GLFWpreedit* preedit = &window->preedit;
+    int textBufferCount = preedit->textBufferCount;
+    while (textBufferCount < textLen + 1)
+        textBufferCount = textBufferCount == 0 ? 1 : textBufferCount * 2;
+    if (textBufferCount != preedit->textBufferCount)
+    {
+        unsigned int* preeditText = _glfw_realloc(preedit->text,
+                                                  sizeof(unsigned int) * textBufferCount);
+        if (preeditText == NULL)
+            return;
+        preedit->text = preeditText;
+        preedit->textBufferCount = textBufferCount;
+    }
+
+    // NSString handles text data in UTF16 by default, so we have to convert them
+    // to UTF32. Not only the encoding, but also the number of characters and
+    // the position of each block.
+    int currentBlockIndex = 0;
+    int currentBlockLength = 0;
+    int currentBlockLocation = 0;
+    int focusedBlockIndex = 0;
+    NSInteger preeditTextLength = 0;
+    NSRange range = NSMakeRange(0, textLen);
+    while (range.length)
+    {
+        uint32_t codepoint = 0;
+        NSRange currentBlockRange;
+        [markedText attributesAtIndex:range.location
+                       effectiveRange:&currentBlockRange];
+
+        if (preedit->blockSizesBufferCount < 1 + currentBlockIndex)
+        {
+            int blockBufferCount = (preedit->blockSizesBufferCount == 0)
+                ? 1 : preedit->blockSizesBufferCount * 2;
+            int* blocks = _glfw_realloc(preedit->blockSizes,
+                                        sizeof(int) * blockBufferCount);
+            if (blocks == NULL)
+                return;
+            preedit->blockSizes = blocks;
+            preedit->blockSizesBufferCount = blockBufferCount;
+        }
+
+        if (currentBlockLocation != currentBlockRange.location)
+        {
+            currentBlockLocation = currentBlockRange.location;
+            preedit->blockSizes[currentBlockIndex++] = currentBlockLength;
+            currentBlockLength = 0;
+            if (selectedRange.location == currentBlockRange.location)
+                focusedBlockIndex = currentBlockIndex;
+        }
+
+        if ([markedTextString getBytes:&codepoint
+                             maxLength:sizeof(codepoint)
+                            usedLength:NULL
+                              encoding:NSUTF32StringEncoding
+                               options:0
+                                 range:range
+                        remainingRange:&range])
+        {
+            if (codepoint >= 0xf700 && codepoint <= 0xf7ff)
+                continue;
+
+            preedit->text[preeditTextLength++] = codepoint;
+            currentBlockLength++;
+        }
+    }
+    preedit->blockSizes[currentBlockIndex] = currentBlockLength;
+    preedit->blockSizesCount = 1 + currentBlockIndex;
+    preedit->textCount = preeditTextLength;
+    preedit->text[preeditTextLength] = 0;
+    preedit->focusedBlockIndex = focusedBlockIndex;
+    // The caret is always at the last of preedit in macOS.
+    preedit->caretIndex = preeditTextLength;
+
+    _glfwInputPreedit(window);
 }
 
 - (void)unmarkText
 {
     [[markedText mutableString] setString:@""];
+    window->preedit.blockSizesCount = 0;
+    window->preedit.textCount = 0;
+    window->preedit.focusedBlockIndex = 0;
+    window->preedit.caretIndex = 0;
+    _glfwInputPreedit(window);
 }
 
 - (NSArray*)validAttributesForMarkedText
@@ -704,8 +794,19 @@ static const NSRange kEmptyRange = { NSNotFound, 0 };
 - (NSRect)firstRectForCharacterRange:(NSRange)range
                          actualRange:(NSRangePointer)actualRange
 {
-    const NSRect frame = [window->ns.view frame];
-    return NSMakeRect(frame.origin.x, frame.origin.y, 0.0, 0.0);
+    int x = window->preedit.cursorPosX;
+    int y = window->preedit.cursorPosY;
+    int w = window->preedit.cursorWidth;
+    int h = window->preedit.cursorHeight;
+
+    const NSRect frame =
+        [window->ns.object contentRectForFrameRect:[window->ns.object frame]];
+
+    return NSMakeRect(frame.origin.x + x,
+                      // The y-axis is upward on macOS, so this conversion is needed.
+                      frame.origin.y + frame.size.height - y - h,
+                      w,
+                      h);
 }
 
 - (void)insertText:(id)string replacementRange:(NSRange)replacementRange
@@ -739,6 +840,8 @@ static const NSRange kEmptyRange = { NSNotFound, 0 };
             _glfwInputChar(window, codepoint, mods, plain);
         }
     }
+
+    [self unmarkText];
 }
 
 - (void)doCommandBySelector:(SEL)selector
@@ -837,7 +940,13 @@ static GLFWbool createNativeWindow(_GLFWwindow* window,
     }
 
     if (window->monitor)
-        [window->ns.object setLevel:NSMainMenuWindowLevel + 1];
+    {
+        if (_glfw.hints.window.softFullscreen)
+            [NSApp setPresentationOptions:NSApplicationPresentationHideDock |
+                                          NSApplicationPresentationHideMenuBar];
+        else
+            [window->ns.object setLevel:NSMainMenuWindowLevel + 1];
+    }
     else
     {
         if (wndconfig->xpos == GLFW_ANY_POSITION ||
@@ -983,6 +1092,12 @@ GLFWbool _glfwCreateWindowCocoa(_GLFWwindow* window,
         }
     }
 
+    [[NSNotificationCenter defaultCenter]
+        addObserver:window->ns.delegate
+           selector:@selector(imeStatusChangeNotified:)
+               name:NSTextInputContextKeyboardSelectionDidChangeNotification
+             object:nil];
+
     return GLFW_TRUE;
 
     } // autoreleasepool
@@ -995,6 +1110,8 @@ void _glfwDestroyWindowCocoa(_GLFWwindow* window)
     if (_glfw.ns.disabledCursorWindow == window)
         _glfw.ns.disabledCursorWindow = NULL;
 
+    [[NSNotificationCenter defaultCenter] removeObserver:window->ns.delegate];
+
     [window->ns.object orderOut:nil];
 
     if (window->monitor)
@@ -1307,7 +1424,12 @@ void _glfwSetWindowMonitorCocoa(_GLFWwindow* window,
 
     if (window->monitor)
     {
-        [window->ns.object setLevel:NSMainMenuWindowLevel + 1];
+        if (_glfw.hints.window.softFullscreen)
+            [NSApp setPresentationOptions:NSApplicationPresentationHideDock |
+                                          NSApplicationPresentationHideMenuBar];
+        else
+            [window->ns.object setLevel:NSMainMenuWindowLevel + 1];
+
         [window->ns.object setHasShadow:NO];
 
         acquireMonitor(window);
@@ -1360,6 +1482,9 @@ void _glfwSetWindowMonitorCocoa(_GLFWwindow* window,
             [window->ns.object setCollectionBehavior:behavior];
         }
 
+        if (_glfw.hints.window.softFullscreen)
+            [NSApp setPresentationOptions:NSApplicationPresentationDefault];
+
         [window->ns.object setHasShadow:YES];
         // HACK: Clearing NSWindowStyleMaskTitled resets and disables the window
         //       title property but the miniwindow title property is unaffected
@@ -1515,6 +1640,17 @@ GLFWbool _glfwRawMouseMotionSupportedCocoa(void)
     return GLFW_FALSE;
 }
 
+void _glfwSetTouchInputCocoa(_GLFWwindow *window, GLFWbool enabled)
+{
+    _glfwInputError(GLFW_FEATURE_UNIMPLEMENTED,
+                    "Cocoa: Touch input not yet implemented");
+}
+
+GLFWbool _glfwTouchInputSupportedCocoa(void)
+{
+    return GLFW_FALSE;
+}
+
 void _glfwPollEventsCocoa(void)
 {
     @autoreleasepool {
@@ -1881,6 +2017,118 @@ const char* _glfwGetClipboardStringCocoa(void)
     } // autoreleasepool
 }
 
+void _glfwUpdatePreeditCursorRectangleCocoa(_GLFWwindow* window)
+{
+    // Do nothing. Instead, implement `firstRectForCharacterRange` callback
+    // to update the position.
+}
+
+void _glfwResetPreeditTextCocoa(_GLFWwindow* window)
+{
+    @autoreleasepool {
+
+    NSTextInputContext* context = [NSTextInputContext currentInputContext];
+    [context discardMarkedText];
+    [window->ns.view unmarkText];
+
+    } // autoreleasepool
+}
+
+void _glfwSetIMEStatusCocoa(_GLFWwindow* window, int active)
+{
+    @autoreleasepool {
+
+    if (active)
+    {
+        NSArray* locales = CFBridgingRelease(CFLocaleCopyPreferredLanguages());
+        // Select the most preferred locale.
+        CFStringRef locale = (__bridge CFStringRef) [locales firstObject];
+        if (locale)
+        {
+            TISInputSourceRef source = TISCopyInputSourceForLanguage(locale);
+            if (source)
+            {
+                CFStringRef sourceType = TISGetInputSourceProperty(source,
+                                                                   kTISPropertyInputSourceType);
+
+                if (sourceType != kTISTypeKeyboardInputMethodModeEnabled)
+                    TISSelectInputSource(source);
+                else
+                {
+                    // Some IMEs return a input-method that has input-method-modes for `TISCopyInputSourceForLanguage()`.
+                    // We can't select these input-methods directly, but need to find
+                    // a input-method-mode of the input-method.
+                    // Example:
+                    //  - Input Method: com.apple.inputmethod.SCIM
+                    //  - Input Mode: com.apple.inputmethod.SCIM.ITABC
+                    NSString* sourceID =
+                        (__bridge NSString *) TISGetInputSourceProperty(source, kTISPropertyInputSourceID);
+                    NSDictionary* properties = @{
+                        (__bridge NSString *) kTISPropertyInputSourceCategory: (__bridge NSString *) kTISCategoryKeyboardInputSource,
+                        (__bridge NSString *) kTISPropertyInputSourceIsSelectCapable: @YES,
+                        };
+                    NSArray* selectableSources =
+                        CFBridgingRelease(TISCreateInputSourceList((__bridge CFDictionaryRef) properties, NO));
+                    for (id sourceCandidate in selectableSources)
+                    {
+                        TISInputSourceRef sourceCandidateRef = (__bridge TISInputSourceRef) sourceCandidate;
+                        NSString* sourceCandidateID =
+                            (__bridge NSString *) TISGetInputSourceProperty(sourceCandidateRef, kTISPropertyInputSourceID);
+                        if ([sourceCandidateID hasPrefix:sourceID])
+                        {
+                            TISSelectInputSource(sourceCandidateRef);
+                            break;
+                        }
+                    }
+                }
+
+                CFRelease(source);
+            }
+        }
+    }
+    else
+    {
+        TISInputSourceRef source = TISCopyCurrentASCIICapableKeyboardInputSource();
+        TISSelectInputSource(source);
+        CFRelease(source);
+    }
+
+    // `NSTextInputContextKeyboardSelectionDidChangeNotification` is sometimes
+    // not called immediately after this, so call the callback here.
+    _glfwInputIMEStatus(window);
+
+    } // autoreleasepool
+}
+
+int _glfwGetIMEStatusCocoa(_GLFWwindow* window)
+{
+    @autoreleasepool {
+
+    NSArray* asciiInputSources =
+        CFBridgingRelease(TISCreateASCIICapableInputSourceList());
+
+    TISInputSourceRef currentSource = TISCopyCurrentKeyboardInputSource();
+    NSString* currentSourceID =
+        (__bridge NSString *) TISGetInputSourceProperty(currentSource,
+                                                        kTISPropertyInputSourceID);
+    CFRelease(currentSource);
+
+    for (int i = 0; i < [asciiInputSources count]; i++)
+    {
+        TISInputSourceRef asciiSource =
+            (__bridge TISInputSourceRef) [asciiInputSources objectAtIndex:i];
+        NSString* asciiSourceID =
+            (__bridge NSString *) TISGetInputSourceProperty(asciiSource,
+                                                            kTISPropertyInputSourceID);
+        if ([asciiSourceID compare:currentSourceID] == NSOrderedSame)
+            return GLFW_FALSE;
+    }
+
+    return GLFW_TRUE;
+
+    } // autoreleasepool
+}
+
 EGLenum _glfwGetEGLPlatformCocoa(EGLint** attribs)
 {
     if (_glfw.egl.ANGLE_platform_angle)
diff --git a/src/init.c b/src/init.c
index 06dbb3f21f..c574554396 100644
--- a/src/init.c
+++ b/src/init.c
@@ -54,6 +54,7 @@ static _GLFWinitconfig _glfwInitHints =
     GLFW_TRUE,      // hat buttons
     GLFW_ANGLE_PLATFORM_TYPE_NONE, // ANGLE backend
     GLFW_ANY_PLATFORM, // preferred platform
+    GLFW_FALSE, // whether to manage preedit candidate
     NULL,           // vkGetInstanceProcAddr function
     {
         GLFW_TRUE,  // macOS menu bar
@@ -61,6 +62,7 @@ static _GLFWinitconfig _glfwInitHints =
     },
     {
         GLFW_TRUE,  // X11 XCB Vulkan surface
+        GLFW_FALSE  // X11 on-the-spot IM-style
     },
     {
         GLFW_WAYLAND_PREFER_LIBDECOR // Wayland libdecor mode
@@ -174,6 +176,29 @@ size_t _glfwEncodeUTF8(char* s, uint32_t codepoint)
     return count;
 }
 
+// Decode a Unicode code point from a UTF-8 stream
+// Based on cutef8 by Jeff Bezanson (Public Domain)
+//
+uint32_t _glfwDecodeUTF8(const char** s)
+{
+    uint32_t codepoint = 0, count = 0;
+    static const uint32_t offsets[] =
+    {
+        0x00000000u, 0x00003080u, 0x000e2080u,
+        0x03c82080u, 0xfa082080u, 0x82082080u
+    };
+
+    do
+    {
+        codepoint = (codepoint << 6) + (unsigned char) **s;
+        (*s)++;
+        count++;
+    } while ((**s & 0xc0) == 0x80);
+
+    assert(count <= 6);
+    return codepoint - offsets[count - 1];
+}
+
 // Splits and translates a text/uri-list into separate file paths
 // NOTE: This function destroys the provided string
 //
@@ -473,6 +498,9 @@ GLFWAPI void glfwInitHint(int hint, int value)
         case GLFW_PLATFORM:
             _glfwInitHints.platformID = value;
             return;
+        case GLFW_MANAGE_PREEDIT_CANDIDATE:
+            _glfwInitHints.managePreeditCandidate = value;
+            return;
         case GLFW_COCOA_CHDIR_RESOURCES:
             _glfwInitHints.ns.chdir = value;
             return;
@@ -482,6 +510,9 @@ GLFWAPI void glfwInitHint(int hint, int value)
         case GLFW_X11_XCB_VULKAN_SURFACE:
             _glfwInitHints.x11.xcbVulkanSurface = value;
             return;
+        case GLFW_X11_ONTHESPOT:
+            _glfwInitHints.x11.onTheSpotIMStyle = value;
+            return;
         case GLFW_WAYLAND_LIBDECOR:
             _glfwInitHints.wl.libdecorMode = value;
             return;
diff --git a/src/input.c b/src/input.c
index 8b7ef29c88..a78a7c9f70 100644
--- a/src/input.c
+++ b/src/input.c
@@ -37,7 +37,7 @@
 #include <string.h>
 
 // Internal key state used for sticky keys
-#define _GLFW_STICK 3
+#define _GLFW_STICK 4
 
 // Internal constants for gamepad mapping source types
 #define _GLFW_JOYSTICK_AXIS     1
@@ -330,6 +330,48 @@ void _glfwInputChar(_GLFWwindow* window, uint32_t codepoint, int mods, GLFWbool
     }
 }
 
+// Notifies shared code of a preedit event
+//
+void _glfwInputPreedit(_GLFWwindow* window)
+{
+    if (window->callbacks.preedit)
+    {
+        _GLFWpreedit *preedit = &window->preedit;
+        window->callbacks.preedit((GLFWwindow*) window,
+                                  preedit->textCount,
+                                  preedit->text,
+                                  preedit->blockSizesCount,
+                                  preedit->blockSizes,
+                                  preedit->focusedBlockIndex,
+                                  preedit->caretIndex);
+    }
+}
+
+// Notifies shared code of a IME status event
+//
+void _glfwInputIMEStatus(_GLFWwindow* window)
+{
+    if (window->callbacks.imestatus)
+    {
+        window->callbacks.imestatus((GLFWwindow*) window);
+    }
+}
+
+// Notifies shared code of a preedit candidate event
+//
+void _glfwInputPreeditCandidate(_GLFWwindow* window)
+{
+    if (window->callbacks.preeditCandidate)
+    {
+        _GLFWpreedit* preedit = &window->preedit;
+        window->callbacks.preeditCandidate((GLFWwindow*) window,
+                                           preedit->candidateCount,
+                                           preedit->candidateSelection,
+                                           preedit->candidatePageStart,
+                                           preedit->candidatePageSize);
+    }
+}
+
 // Notifies shared code of a scroll event
 //
 void _glfwInputScroll(_GLFWwindow* window, double xoffset, double yoffset)
@@ -413,6 +455,14 @@ void _glfwInputDrop(_GLFWwindow* window, int count, const char** paths)
         window->callbacks.drop((GLFWwindow*) window, count, paths);
 }
 
+// Notifies shared code of touch events
+//
+void _glfwInputTouch(_GLFWwindow* window, int touch, int action, double xpos, double ypos)
+{
+    if (window->callbacks.touch)
+        window->callbacks.touch((GLFWwindow*) window, touch, action, xpos, ypos);
+}
+
 // Notifies shared code of a joystick connection or disconnection
 //
 void _glfwInputJoystick(_GLFWjoystick* js, int event)
@@ -574,10 +624,14 @@ GLFWAPI int glfwGetInputMode(GLFWwindow* handle, int mode)
             return window->stickyKeys;
         case GLFW_STICKY_MOUSE_BUTTONS:
             return window->stickyMouseButtons;
+        case GLFW_TOUCH:
+            return window->touchInput;
         case GLFW_LOCK_KEY_MODS:
             return window->lockKeyMods;
         case GLFW_RAW_MOUSE_MOTION:
             return window->rawMouseMotion;
+        case GLFW_IME:
+            return _glfw.platform.getIMEStatus(window);
     }
 
     _glfwInputError(GLFW_INVALID_ENUM, "Invalid input mode 0x%08X", mode);
@@ -685,6 +739,30 @@ GLFWAPI void glfwSetInputMode(GLFWwindow* handle, int mode, int value)
             _glfw.platform.setRawMouseMotion(window, value);
             return;
         }
+
+        case GLFW_IME:
+        {
+            _glfw.platform.setIMEStatus(window, value ? GLFW_TRUE : GLFW_FALSE);
+            return;
+        }
+
+        case GLFW_TOUCH:
+        {
+            if (!_glfw.platform.touchInputSupported())
+            {
+                _glfwInputError(GLFW_PLATFORM_ERROR,
+                                "Touch input is not supported on this system");
+                return;
+            }
+
+            value = value ? GLFW_TRUE : GLFW_FALSE;
+            if (window->touchInput == value)
+                return;
+
+            window->touchInput = value;
+            _glfw.platform.setTouchInput(window, value);
+            return;
+        }
     }
 
     _glfwInputError(GLFW_INVALID_ENUM, "Invalid input mode 0x%08X", mode);
@@ -696,6 +774,12 @@ GLFWAPI int glfwRawMouseMotionSupported(void)
     return _glfw.platform.rawMouseMotionSupported();
 }
 
+GLFWAPI int glfwTouchInputSupported(void)
+{
+    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);
+    return _glfw.platform.touchInputSupported();
+}
+
 GLFWAPI const char* glfwGetKeyName(int key, int scancode)
 {
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
@@ -945,6 +1029,62 @@ GLFWAPI void glfwSetCursor(GLFWwindow* windowHandle, GLFWcursor* cursorHandle)
     _glfw.platform.setCursor(window, cursor);
 }
 
+GLFWAPI void glfwGetPreeditCursorRectangle(GLFWwindow* handle, int* x, int* y, int* w, int* h)
+{
+    _GLFWwindow* window = (_GLFWwindow*) handle;
+    _GLFWpreedit* preedit = &window->preedit;
+    if (x)
+        *x = preedit->cursorPosX;
+    if (y)
+        *y = preedit->cursorPosY;
+    if (w)
+        *w = preedit->cursorWidth;
+    if (h)
+        *h = preedit->cursorHeight;
+}
+
+GLFWAPI void glfwSetPreeditCursorRectangle(GLFWwindow* handle, int x, int y, int w, int h)
+{
+    _GLFWwindow* window = (_GLFWwindow*) handle;
+    _GLFWpreedit* preedit = &window->preedit;
+
+    if (x == preedit->cursorPosX &&
+        y == preedit->cursorPosY &&
+        w == preedit->cursorWidth &&
+        h == preedit->cursorHeight)
+    {
+        return;
+    }
+
+    preedit->cursorPosX = x;
+    preedit->cursorPosY = y;
+    preedit->cursorWidth = w;
+    preedit->cursorHeight = h;
+
+    _glfw.platform.updatePreeditCursorRectangle(window);
+}
+
+GLFWAPI void glfwResetPreeditText(GLFWwindow* handle)
+{
+    _GLFWwindow* window = (_GLFWwindow*) handle;
+    _glfw.platform.resetPreeditText(window);
+}
+
+GLFWAPI unsigned int* glfwGetPreeditCandidate(GLFWwindow* handle, int index, int* textCount)
+{
+    _GLFWwindow* window = (_GLFWwindow*) handle;
+    _GLFWpreedit* preedit = &window->preedit;
+
+    if (preedit->candidateCount <= index)
+        return NULL;
+
+    if (textCount)
+        *textCount = preedit->candidates[index].textCount;
+
+
+    return preedit->candidates[index].text;
+}
+
 GLFWAPI GLFWkeyfun glfwSetKeyCallback(GLFWwindow* handle, GLFWkeyfun cbfun)
 {
     _GLFWwindow* window = (_GLFWwindow*) handle;
@@ -975,6 +1115,31 @@ GLFWAPI GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow* handle, GLFWcharmods
     return cbfun;
 }
 
+GLFWAPI GLFWpreeditfun glfwSetPreeditCallback(GLFWwindow* handle, GLFWpreeditfun cbfun)
+{
+    _GLFWwindow* window = (_GLFWwindow*) handle;
+    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+    _GLFW_SWAP(GLFWpreeditfun, window->callbacks.preedit, cbfun);
+    return cbfun;
+}
+
+GLFWAPI GLFWimestatusfun glfwSetIMEStatusCallback(GLFWwindow* handle, GLFWimestatusfun cbfun)
+{
+    _GLFWwindow* window = (_GLFWwindow*) handle;
+    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+    _GLFW_SWAP(GLFWimestatusfun, window->callbacks.imestatus, cbfun);
+    return cbfun;
+}
+
+GLFWAPI GLFWpreeditcandidatefun glfwSetPreeditCandidateCallback(GLFWwindow* handle,
+                                                                GLFWpreeditcandidatefun cbfun)
+{
+    _GLFWwindow* window = (_GLFWwindow*) handle;
+    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+    _GLFW_SWAP(GLFWpreeditcandidatefun, window->callbacks.preeditCandidate, cbfun);
+    return cbfun;
+}
+
 GLFWAPI GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* handle,
                                                       GLFWmousebuttonfun cbfun)
 {
@@ -1458,6 +1623,14 @@ GLFWAPI int glfwGetGamepadState(int jid, GLFWgamepadstate* state)
     return GLFW_TRUE;
 }
 
+GLFWAPI GLFWtouchfun glfwSetTouchCallback(GLFWwindow* handle, GLFWtouchfun cbfun)
+{
+    _GLFWwindow* window = (_GLFWwindow*) handle;
+    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+    _GLFW_SWAP(GLFWtouchfun, window->callbacks.touch, cbfun);
+    return cbfun;
+}
+
 GLFWAPI void glfwSetClipboardString(GLFWwindow* handle, const char* string)
 {
     assert(string != NULL);
diff --git a/src/internal.h b/src/internal.h
index fe0369aaf9..ad82f2cc02 100644
--- a/src/internal.h
+++ b/src/internal.h
@@ -61,22 +61,24 @@
 typedef int GLFWbool;
 typedef void (*GLFWproc)(void);
 
-typedef struct _GLFWerror       _GLFWerror;
-typedef struct _GLFWinitconfig  _GLFWinitconfig;
-typedef struct _GLFWwndconfig   _GLFWwndconfig;
-typedef struct _GLFWctxconfig   _GLFWctxconfig;
-typedef struct _GLFWfbconfig    _GLFWfbconfig;
-typedef struct _GLFWcontext     _GLFWcontext;
-typedef struct _GLFWwindow      _GLFWwindow;
-typedef struct _GLFWplatform    _GLFWplatform;
-typedef struct _GLFWlibrary     _GLFWlibrary;
-typedef struct _GLFWmonitor     _GLFWmonitor;
-typedef struct _GLFWcursor      _GLFWcursor;
-typedef struct _GLFWmapelement  _GLFWmapelement;
-typedef struct _GLFWmapping     _GLFWmapping;
-typedef struct _GLFWjoystick    _GLFWjoystick;
-typedef struct _GLFWtls         _GLFWtls;
-typedef struct _GLFWmutex       _GLFWmutex;
+typedef struct _GLFWerror            _GLFWerror;
+typedef struct _GLFWinitconfig       _GLFWinitconfig;
+typedef struct _GLFWwndconfig        _GLFWwndconfig;
+typedef struct _GLFWctxconfig        _GLFWctxconfig;
+typedef struct _GLFWfbconfig         _GLFWfbconfig;
+typedef struct _GLFWcontext          _GLFWcontext;
+typedef struct _GLFWpreedit          _GLFWpreedit;
+typedef struct _GLFWpreeditcandidate _GLFWpreeditcandidate;
+typedef struct _GLFWwindow           _GLFWwindow;
+typedef struct _GLFWplatform         _GLFWplatform;
+typedef struct _GLFWlibrary          _GLFWlibrary;
+typedef struct _GLFWmonitor          _GLFWmonitor;
+typedef struct _GLFWcursor           _GLFWcursor;
+typedef struct _GLFWmapelement       _GLFWmapelement;
+typedef struct _GLFWmapping          _GLFWmapping;
+typedef struct _GLFWjoystick         _GLFWjoystick;
+typedef struct _GLFWtls              _GLFWtls;
+typedef struct _GLFWmutex            _GLFWmutex;
 
 #define GL_VERSION 0x1f02
 #define GL_NONE 0
@@ -371,6 +373,7 @@ struct _GLFWinitconfig
     GLFWbool      hatButtons;
     int           angleType;
     int           platformID;
+    GLFWbool      managePreeditCandidate;
     PFN_vkGetInstanceProcAddr vulkanLoader;
     struct {
         GLFWbool  menubar;
@@ -378,6 +381,7 @@ struct _GLFWinitconfig
     } ns;
     struct {
         GLFWbool  xcbVulkanSurface;
+        GLFWbool  onTheSpotIMStyle;
     } x11;
     struct {
         int       libdecorMode;
@@ -408,6 +412,7 @@ struct _GLFWwndconfig
     GLFWbool      focusOnShow;
     GLFWbool      mousePassthrough;
     GLFWbool      scaleToMonitor;
+    GLFWbool      softFullscreen;
     struct {
         GLFWbool  retina;
         char      frameName[256];
@@ -518,6 +523,39 @@ struct _GLFWcontext
     GLFW_PLATFORM_CONTEXT_STATE
 };
 
+// Preedit structure for Input Method Editor/Engine
+//
+struct _GLFWpreedit
+{
+    unsigned int*          text;
+    int                    textCount;
+    int                    textBufferCount;
+    int*                   blockSizes;
+    int                    blockSizesCount;
+    int                    blockSizesBufferCount;
+    int                    focusedBlockIndex;
+    int                    caretIndex;
+    int                    cursorPosX, cursorPosY, cursorWidth, cursorHeight;
+
+    // Used only when apps display candidates by themselves.
+    // Usually, OS displays them, so apps don't need to do it.
+    _GLFWpreeditcandidate* candidates;
+    int                    candidateCount;
+    int                    candidateBufferCount;
+    int                    candidateSelection;
+    int                    candidatePageStart;
+    int                    candidatePageSize;
+};
+
+// Preedit candidate structure
+//
+struct _GLFWpreeditcandidate
+{
+    unsigned int*       text;
+    int                 textCount;
+    int                 textBufferCount;
+};
+
 // Window and context structure
 //
 struct _GLFWwindow
@@ -544,6 +582,7 @@ struct _GLFWwindow
 
     GLFWbool            stickyKeys;
     GLFWbool            stickyMouseButtons;
+    GLFWbool            touchInput;
     GLFWbool            lockKeyMods;
     int                 cursorMode;
     char                mouseButtons[GLFW_MOUSE_BUTTON_LAST + 1];
@@ -554,6 +593,8 @@ struct _GLFWwindow
 
     _GLFWcontext        context;
 
+    _GLFWpreedit        preedit;
+
     struct {
         GLFWwindowposfun          pos;
         GLFWwindowsizefun         size;
@@ -571,7 +612,11 @@ struct _GLFWwindow
         GLFWkeyfun                key;
         GLFWcharfun               character;
         GLFWcharmodsfun           charmods;
+        GLFWpreeditfun            preedit;
+        GLFWimestatusfun          imestatus;
+        GLFWpreeditcandidatefun   preeditCandidate;
         GLFWdropfun               drop;
+        GLFWtouchfun              touch;
     } callbacks;
 
     // This is defined in platform.h
@@ -690,6 +735,12 @@ struct _GLFWplatform
     int (*getKeyScancode)(int);
     void (*setClipboardString)(const char*);
     const char* (*getClipboardString)(void);
+    void (*updatePreeditCursorRectangle)(_GLFWwindow*);
+    void (*resetPreeditText)(_GLFWwindow*);
+    void (*setIMEStatus)(_GLFWwindow*,int);
+    int  (*getIMEStatus)(_GLFWwindow*);
+    void (*setTouchInput)(_GLFWwindow*,int);
+    GLFWbool (*touchInputSupported)(void);
     GLFWbool (*initJoysticks)(void);
     void (*terminateJoysticks)(void);
     GLFWbool (*pollJoystick)(_GLFWjoystick*,int);
@@ -922,10 +973,15 @@ void _glfwInputKey(_GLFWwindow* window,
                    int key, int scancode, int action, int mods);
 void _glfwInputChar(_GLFWwindow* window,
                     uint32_t codepoint, int mods, GLFWbool plain);
+void _glfwInputPreedit(_GLFWwindow* window);
+void _glfwInputIMEStatus(_GLFWwindow* window);
+void _glfwInputPreeditCandidate(_GLFWwindow* window);
 void _glfwInputScroll(_GLFWwindow* window, double xoffset, double yoffset);
 void _glfwInputMouseClick(_GLFWwindow* window, int button, int action, int mods);
 void _glfwInputCursorPos(_GLFWwindow* window, double xpos, double ypos);
 void _glfwInputCursorEnter(_GLFWwindow* window, GLFWbool entered);
+void _glfwInputTouch(_GLFWwindow* window, int touch, int action, double xpos, double ypos);
+
 void _glfwInputDrop(_GLFWwindow* window, int count, const char** names);
 void _glfwInputJoystick(_GLFWjoystick* js, int event);
 void _glfwInputJoystickAxis(_GLFWjoystick* js, int axis, float value);
@@ -998,6 +1054,7 @@ void _glfwTerminateVulkan(void);
 const char* _glfwGetVulkanResultString(VkResult result);
 
 size_t _glfwEncodeUTF8(char* s, uint32_t codepoint);
+uint32_t _glfwDecodeUTF8(const char** s);
 char** _glfwParseUriList(char* text, int* count);
 
 char* _glfw_strdup(const char* source);
diff --git a/src/null_init.c b/src/null_init.c
index 7236c98c28..b26721eae4 100644
--- a/src/null_init.c
+++ b/src/null_init.c
@@ -57,6 +57,12 @@ GLFWbool _glfwConnectNull(int platformID, _GLFWplatform* platform)
         _glfwGetKeyScancodeNull,
         _glfwSetClipboardStringNull,
         _glfwGetClipboardStringNull,
+        _glfwUpdatePreeditCursorRectangleNull,
+        _glfwResetPreeditTextNull,
+        _glfwSetIMEStatusNull,
+        _glfwGetIMEStatusNull,
+        _glfwSetTouchInputNull,
+        _glfwTouchInputSupportedNull,
         _glfwInitJoysticksNull,
         _glfwTerminateJoysticksNull,
         _glfwPollJoystickNull,
diff --git a/src/null_platform.h b/src/null_platform.h
index fb9374b434..9bfb975acd 100644
--- a/src/null_platform.h
+++ b/src/null_platform.h
@@ -260,6 +260,14 @@ const char* _glfwGetClipboardStringNull(void);
 const char* _glfwGetScancodeNameNull(int scancode);
 int _glfwGetKeyScancodeNull(int key);
 
+void _glfwUpdatePreeditCursorRectangleNull(_GLFWwindow* window);
+void _glfwResetPreeditTextNull(_GLFWwindow* window);
+void _glfwSetIMEStatusNull(_GLFWwindow* window, int active);
+int _glfwGetIMEStatusNull(_GLFWwindow* window);
+
+void _glfwSetTouchInputNull(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwTouchInputSupportedNull(void);
+
 EGLenum _glfwGetEGLPlatformNull(EGLint** attribs);
 EGLNativeDisplayType _glfwGetEGLNativeDisplayNull(void);
 EGLNativeWindowType _glfwGetEGLNativeWindowNull(_GLFWwindow* window);
diff --git a/src/null_window.c b/src/null_window.c
index e0bbb3b6b2..71fec12661 100644
--- a/src/null_window.c
+++ b/src/null_window.c
@@ -432,6 +432,15 @@ void _glfwShowWindowNull(_GLFWwindow* window)
     window->null.visible = GLFW_TRUE;
 }
 
+void _glfwSetTouchInputNull(_GLFWwindow *window, GLFWbool enabled)
+{
+}
+
+GLFWbool _glfwTouchInputSupportedNull(void)
+{
+    return GLFW_TRUE;
+}
+
 void _glfwRequestWindowAttentionNull(_GLFWwindow* window)
 {
 }
@@ -551,6 +560,23 @@ const char* _glfwGetClipboardStringNull(void)
     return _glfw.null.clipboardString;
 }
 
+void _glfwUpdatePreeditCursorRectangleNull(_GLFWwindow* window)
+{
+}
+
+void _glfwResetPreeditTextNull(_GLFWwindow* window)
+{
+}
+
+void _glfwSetIMEStatusNull(_GLFWwindow* window, int active)
+{
+}
+
+int _glfwGetIMEStatusNull(_GLFWwindow* window)
+{
+    return GLFW_FALSE;
+}
+
 EGLenum _glfwGetEGLPlatformNull(EGLint** attribs)
 {
     return 0;
diff --git a/src/win32_init.c b/src/win32_init.c
index ef2615f14b..ed5ab24aa6 100644
--- a/src/win32_init.c
+++ b/src/win32_init.c
@@ -113,6 +113,23 @@ static GLFWbool loadLibraries(void)
             _glfwPlatformGetModuleSymbol(_glfw.win32.dinput8.instance, "DirectInput8Create");
     }
 
+    _glfw.win32.user32.GetTouchInputInfo_ = (PFN_GetTouchInputInfo)
+        GetProcAddress(_glfw.win32.user32.instance, "GetTouchInputInfo");
+    _glfw.win32.user32.CloseTouchInputHandle_ = (PFN_CloseTouchInputHandle)
+        GetProcAddress(_glfw.win32.user32.instance, "CloseTouchInputHandle");
+    _glfw.win32.user32.RegisterTouchWindow_ = (PFN_RegisterTouchWindow)
+        GetProcAddress(_glfw.win32.user32.instance, "RegisterTouchWindow");
+    _glfw.win32.user32.UnregisterTouchWindow_ = (PFN_UnregisterTouchWindow)
+        GetProcAddress(_glfw.win32.user32.instance, "UnregisterTouchWindow");
+
+    if (_glfw.win32.user32.GetTouchInputInfo_ &&
+        _glfw.win32.user32.CloseTouchInputHandle_ &&
+        _glfw.win32.user32.RegisterTouchWindow_ &&
+        _glfw.win32.user32.UnregisterTouchWindow_)
+    {
+        _glfw.win32.touch.available = GLFW_TRUE;
+    }
+
     {
         int i;
         const char* names[] =
@@ -169,6 +186,31 @@ static GLFWbool loadLibraries(void)
             _glfwPlatformGetModuleSymbol(_glfw.win32.ntdll.instance, "RtlVerifyVersionInfo");
     }
 
+    _glfw.win32.imm32.instance = _glfwPlatformLoadModule("imm32.dll");
+    if (_glfw.win32.imm32.instance)
+    {
+        _glfw.win32.imm32.ImmGetCandidateListW_ = (PFN_ImmGetCandidateListW)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmGetCandidateListW");
+        _glfw.win32.imm32.ImmGetCompositionStringW_ = (PFN_ImmGetCompositionStringW)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmGetCompositionStringW");
+        _glfw.win32.imm32.ImmGetContext_ = (PFN_ImmGetContext)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmGetContext");
+        _glfw.win32.imm32.ImmGetConversionStatus_ = (PFN_ImmGetConversionStatus)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmGetConversionStatus");
+        _glfw.win32.imm32.ImmGetDescriptionW_ = (PFN_ImmGetDescriptionW)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmGetDescriptionW");
+        _glfw.win32.imm32.ImmGetOpenStatus_ = (PFN_ImmGetOpenStatus)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmGetOpenStatus");
+        _glfw.win32.imm32.ImmNotifyIME_ = (PFN_ImmNotifyIME)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmNotifyIME");
+        _glfw.win32.imm32.ImmReleaseContext_ = (PFN_ImmReleaseContext)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmReleaseContext");
+        _glfw.win32.imm32.ImmSetCandidateWindow_ = (PFN_ImmSetCandidateWindow)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmSetCandidateWindow");
+        _glfw.win32.imm32.ImmSetOpenStatus_ = (PFN_ImmSetOpenStatus)
+            _glfwPlatformGetModuleSymbol(_glfw.win32.imm32.instance, "ImmSetOpenStatus");
+    }
+
     return GLFW_TRUE;
 }
 
@@ -193,6 +235,9 @@ static void freeLibraries(void)
 
     if (_glfw.win32.ntdll.instance)
         _glfwPlatformFreeModule(_glfw.win32.ntdll.instance);
+
+    if (_glfw.win32.imm32.instance)
+        _glfwPlatformFreeModule(_glfw.win32.imm32.instance);
 }
 
 // Create key code translation tables
@@ -621,6 +666,12 @@ GLFWbool _glfwConnectWin32(int platformID, _GLFWplatform* platform)
         _glfwGetKeyScancodeWin32,
         _glfwSetClipboardStringWin32,
         _glfwGetClipboardStringWin32,
+        _glfwUpdatePreeditCursorRectangleWin32,
+        _glfwResetPreeditTextWin32,
+        _glfwSetIMEStatusWin32,
+        _glfwGetIMEStatusWin32,
+        _glfwSetTouchInputWin32,
+        _glfwTouchInputSupportedWin32,
         _glfwInitJoysticksWin32,
         _glfwTerminateJoysticksWin32,
         _glfwPollJoystickWin32,
diff --git a/src/win32_platform.h b/src/win32_platform.h
index 82b34bb9dc..a0c10439c8 100644
--- a/src/win32_platform.h
+++ b/src/win32_platform.h
@@ -69,6 +69,7 @@
 #include <dinput.h>
 #include <xinput.h>
 #include <dbt.h>
+#include <imm.h>
 
 // HACK: Define macros that some windows.h variants don't
 #ifndef WM_MOUSEHWHEEL
@@ -270,6 +271,37 @@ typedef enum
 #define ERROR_INVALID_PROFILE_ARB 0x2096
 #define ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB 0x2054
 
+#if WINVER < 0x0601
+#define WM_TOUCH 0x0240
+
+DECLARE_HANDLE(HTOUCHINPUT);
+
+typedef struct tagTOUCHINPUT
+{
+    LONG x;
+    LONG y;
+    HANDLE hSource;
+    DWORD dwID;
+    DWORD dwFlags;
+    DWORD dwMask;
+    DWORD dwTime;
+    ULONG_PTR dwExtraInfo;
+    DWORD cxContact;
+    DWORD cyContext;
+} TOUCHINPUT, *PTOUCHINPUT;
+
+#define TOUCH_COORD_TO_PIXEL(x) ((x) / 100)
+
+#define TOUCHEVENTF_MOVE    0x0001
+#define TOUCHEVENTF_DOWN    0x0002
+#define TOUCHEVENTF_UP      0x0004
+
+#endif /*WINVER < 0x0601*/
+
+// winmm.dll function pointer typedefs
+typedef DWORD (WINAPI * PFN_timeGetTime)(void);
+#define timeGetTime _glfw.win32.winmm.GetTime
+
 // xinput.dll function pointer typedefs
 typedef DWORD (WINAPI * PFN_XInputGetCapabilities)(DWORD,DWORD,XINPUT_CAPABILITIES*);
 typedef DWORD (WINAPI * PFN_XInputGetState)(DWORD,XINPUT_STATE*);
@@ -288,6 +320,10 @@ typedef BOOL (WINAPI * PFN_SetProcessDpiAwarenessContext)(HANDLE);
 typedef UINT (WINAPI * PFN_GetDpiForWindow)(HWND);
 typedef BOOL (WINAPI * PFN_AdjustWindowRectExForDpi)(LPRECT,DWORD,BOOL,DWORD,UINT);
 typedef int (WINAPI * PFN_GetSystemMetricsForDpi)(int,UINT);
+typedef BOOL (WINAPI * PFN_GetTouchInputInfo)(HTOUCHINPUT,UINT,PTOUCHINPUT,int);
+typedef BOOL (WINAPI * PFN_CloseTouchInputHandle)(HTOUCHINPUT);
+typedef BOOL (WINAPI * PFN_RegisterTouchWindow)(HWND,LONG);
+typedef BOOL (WINAPI * PFN_UnregisterTouchWindow)(HWND);
 #define SetProcessDPIAware _glfw.win32.user32.SetProcessDPIAware_
 #define ChangeWindowMessageFilterEx _glfw.win32.user32.ChangeWindowMessageFilterEx_
 #define EnableNonClientDpiScaling _glfw.win32.user32.EnableNonClientDpiScaling_
@@ -295,6 +331,10 @@ typedef int (WINAPI * PFN_GetSystemMetricsForDpi)(int,UINT);
 #define GetDpiForWindow _glfw.win32.user32.GetDpiForWindow_
 #define AdjustWindowRectExForDpi _glfw.win32.user32.AdjustWindowRectExForDpi_
 #define GetSystemMetricsForDpi _glfw.win32.user32.GetSystemMetricsForDpi_
+#define GetTouchInputInfo _glfw.win32.user32.GetTouchInputInfo_
+#define CloseTouchInputHandle _glfw.win32.user32.CloseTouchInputHandle_
+#define RegisterTouchWindow _glfw.win32.user32.RegisterTouchWindow_
+#define UnregisterTouchWindow _glfw.win32.user32.UnregisterTouchWindow_
 
 // dwmapi.dll function pointer typedefs
 typedef HRESULT (WINAPI * PFN_DwmIsCompositionEnabled)(BOOL*);
@@ -316,6 +356,28 @@ typedef HRESULT (WINAPI * PFN_GetDpiForMonitor)(HMONITOR,MONITOR_DPI_TYPE,UINT*,
 typedef LONG (WINAPI * PFN_RtlVerifyVersionInfo)(OSVERSIONINFOEXW*,ULONG,ULONGLONG);
 #define RtlVerifyVersionInfo _glfw.win32.ntdll.RtlVerifyVersionInfo_
 
+// imm32 function pointer typedefs
+typedef DWORD  (WINAPI * PFN_ImmGetCandidateListW)(HIMC,DWORD,LPCANDIDATELIST,DWORD);
+typedef LONG (WINAPI * PFN_ImmGetCompositionStringW)(HIMC,DWORD,LPVOID,DWORD);
+typedef HIMC (WINAPI * PFN_ImmGetContext)(HWND);
+typedef BOOL (WINAPI * PFN_ImmGetConversionStatus)(HIMC,LPDWORD,LPDWORD);
+typedef UINT (WINAPI * PFN_ImmGetDescriptionW)(HKL,LPWSTR,UINT);
+typedef BOOL (WINAPI * PFN_ImmGetOpenStatus)(HIMC);
+typedef BOOL (WINAPI * PFN_ImmNotifyIME)(HIMC,DWORD,DWORD,DWORD);
+typedef BOOL (WINAPI * PFN_ImmReleaseContext)(HWND,HIMC);
+typedef BOOL (WINAPI * PFN_ImmSetCandidateWindow)(HIMC,LPCANDIDATEFORM);
+typedef BOOL (WINAPI * PFN_ImmSetOpenStatus)(HIMC,BOOL);
+#define ImmGetCandidateListW _glfw.win32.imm32.ImmGetCandidateListW_
+#define ImmGetCompositionStringW _glfw.win32.imm32.ImmGetCompositionStringW_
+#define ImmGetContext _glfw.win32.imm32.ImmGetContext_
+#define ImmGetConversionStatus _glfw.win32.imm32.ImmGetConversionStatus_
+#define ImmGetDescriptionW _glfw.win32.imm32.ImmGetDescriptionW_
+#define ImmGetOpenStatus _glfw.win32.imm32.ImmGetOpenStatus_
+#define ImmNotifyIME _glfw.win32.imm32.ImmNotifyIME_
+#define ImmReleaseContext _glfw.win32.imm32.ImmReleaseContext_
+#define ImmSetCandidateWindow _glfw.win32.imm32.ImmSetCandidateWindow_
+#define ImmSetOpenStatus _glfw.win32.imm32.ImmSetOpenStatus_
+
 // WGL extension pointer typedefs
 typedef BOOL (WINAPI * PFNWGLSWAPINTERVALEXTPROC)(int);
 typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBIVARBPROC)(HDC,int,int,UINT,const int*,int*);
@@ -479,8 +541,16 @@ typedef struct _GLFWlibraryWin32
         PFN_GetDpiForWindow             GetDpiForWindow_;
         PFN_AdjustWindowRectExForDpi    AdjustWindowRectExForDpi_;
         PFN_GetSystemMetricsForDpi      GetSystemMetricsForDpi_;
+        PFN_GetTouchInputInfo           GetTouchInputInfo_;
+        PFN_CloseTouchInputHandle       CloseTouchInputHandle_;
+        PFN_RegisterTouchWindow         RegisterTouchWindow_;
+        PFN_UnregisterTouchWindow       UnregisterTouchWindow_;
     } user32;
 
+    struct {
+        GLFWbool                        available;
+    } touch;
+
     struct {
         HINSTANCE                       instance;
         PFN_DwmIsCompositionEnabled     IsCompositionEnabled;
@@ -499,6 +569,20 @@ typedef struct _GLFWlibraryWin32
         HINSTANCE                       instance;
         PFN_RtlVerifyVersionInfo        RtlVerifyVersionInfo_;
     } ntdll;
+
+    struct {
+        HINSTANCE                       instance;
+        PFN_ImmGetCandidateListW        ImmGetCandidateListW_;
+        PFN_ImmGetCompositionStringW    ImmGetCompositionStringW_;
+        PFN_ImmGetContext               ImmGetContext_;
+        PFN_ImmGetConversionStatus      ImmGetConversionStatus_;
+        PFN_ImmGetDescriptionW          ImmGetDescriptionW_;
+        PFN_ImmGetOpenStatus            ImmGetOpenStatus_;
+        PFN_ImmNotifyIME                ImmNotifyIME_;
+        PFN_ImmReleaseContext           ImmReleaseContext_;
+        PFN_ImmSetCandidateWindow       ImmSetCandidateWindow_;
+        PFN_ImmSetOpenStatus            ImmSetOpenStatus_;
+    } imm32;
 } _GLFWlibraryWin32;
 
 // Win32-specific per-monitor data
@@ -576,6 +660,9 @@ void _glfwSetWindowOpacityWin32(_GLFWwindow* window, float opacity);
 void _glfwSetRawMouseMotionWin32(_GLFWwindow *window, GLFWbool enabled);
 GLFWbool _glfwRawMouseMotionSupportedWin32(void);
 
+void _glfwSetTouchInputWin32(_GLFWwindow* window, int enabled);
+GLFWbool _glfwTouchInputSupportedWin32(void);
+
 void _glfwPollEventsWin32(void);
 void _glfwWaitEventsWin32(void);
 void _glfwWaitEventsTimeoutWin32(double timeout);
@@ -593,6 +680,11 @@ void _glfwSetCursorWin32(_GLFWwindow* window, _GLFWcursor* cursor);
 void _glfwSetClipboardStringWin32(const char* string);
 const char* _glfwGetClipboardStringWin32(void);
 
+void _glfwUpdatePreeditCursorRectangleWin32(_GLFWwindow* window);
+void _glfwResetPreeditTextWin32(_GLFWwindow* window);
+void _glfwSetIMEStatusWin32(_GLFWwindow* window, int active);
+int _glfwGetIMEStatusWin32(_GLFWwindow* window);
+
 EGLenum _glfwGetEGLPlatformWin32(EGLint** attribs);
 EGLNativeDisplayType _glfwGetEGLNativeDisplayWin32(void);
 EGLNativeWindowType _glfwGetEGLNativeWindowWin32(_GLFWwindow* window);
diff --git a/src/win32_window.c b/src/win32_window.c
index a4a1817172..358deb714b 100644
--- a/src/win32_window.c
+++ b/src/win32_window.c
@@ -36,6 +36,42 @@
 #include <string.h>
 #include <windowsx.h>
 #include <shellapi.h>
+#include <wchar.h>
+
+// Converts utf16 units to Unicode code points (UTF32).
+// Returns GLFW_TRUE when the converting completes and the result is assigned to
+// the argument `codepoint`.
+// Returns GLFW_FALSE when the converting is not yet completed (for
+// Surrogate-pair processing) and the unit is assigned to the argument
+// `highsurrogate`. It will be used in the next unit's processing.
+//
+static GLFWbool convertToUTF32FromUTF16(WCHAR utf16_unit,
+                                        WCHAR* highsurrogate,
+                                        uint32_t* codepoint)
+{
+    *codepoint = 0;
+
+    if (utf16_unit >= 0xd800 && utf16_unit <= 0xdbff)
+    {
+        *highsurrogate = (WCHAR) utf16_unit;
+        return GLFW_FALSE;
+    }
+
+    if (utf16_unit >= 0xdc00 && utf16_unit <= 0xdfff)
+    {
+        if (*highsurrogate)
+        {
+            *codepoint += (*highsurrogate - 0xd800) << 10;
+            *codepoint += (WCHAR) utf16_unit - 0xdc00;
+            *codepoint += 0x10000;
+        }
+    }
+    else
+        *codepoint = (WCHAR) utf16_unit;
+
+    *highsurrogate = 0;
+    return GLFW_TRUE;
+}
 
 // Returns the window style for the specified window
 //
@@ -426,11 +462,18 @@ static void fitToMonitor(_GLFWwindow* window)
 {
     MONITORINFO mi = { sizeof(mi) };
     GetMonitorInfoW(window->monitor->win32.handle, &mi);
+    // On Win32, the window behaves in a special way when the window covers the screen exactly.
+    // In this case, the window is a strong exclusive exceeding HWND_TOPMOST and it doen't
+    // display OS notifications such as the sound volumn changed.
+    // This behavior can be deactivated by shifting the size slightly.
+    // This is especially necessary for the IME(Input Method Editor/Engine) to display properly.
+    // This can also effect transparency to fullscreen.
     SetWindowPos(window->win32.handle, HWND_TOPMOST,
                  mi.rcMonitor.left,
                  mi.rcMonitor.top,
                  mi.rcMonitor.right - mi.rcMonitor.left,
-                 mi.rcMonitor.bottom - mi.rcMonitor.top,
+                 _glfw.hints.window.softFullscreen ? mi.rcMonitor.bottom - mi.rcMonitor.top + 1
+                                                   : mi.rcMonitor.bottom - mi.rcMonitor.top,
                  SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);
 }
 
@@ -525,6 +568,318 @@ static void maximizeWindowManually(_GLFWwindow* window)
                  SWP_NOACTIVATE | SWP_NOZORDER | SWP_FRAMECHANGED);
 }
 
+// Store candidate text from the buffer data
+//
+static void setCandidate(_GLFWpreeditcandidate* candidate, LPWSTR buffer)
+{
+    size_t bufferCount = wcslen(buffer);
+    int textBufferCount = candidate->textBufferCount;
+    uint32_t codepoint;
+    WCHAR highSurrogate = 0;
+    int convertedLength = 0;
+    int i;
+
+    while ((size_t) textBufferCount < bufferCount + 1)
+        textBufferCount = (textBufferCount == 0) ? 1 : textBufferCount * 2;
+    if (textBufferCount != candidate->textBufferCount)
+    {
+        unsigned int* text =
+            _glfw_realloc(candidate->text,
+                          sizeof(unsigned int) * textBufferCount);
+        if (text == NULL)
+            return;
+        candidate->text = text;
+        candidate->textBufferCount = textBufferCount;
+    }
+
+    for (i = 0; (size_t) i < bufferCount; ++i)
+    {
+        if (convertToUTF32FromUTF16(buffer[i],
+                                    &highSurrogate,
+                                    &codepoint))
+            candidate->text[convertedLength++] = codepoint;
+    }
+
+    candidate->textCount = convertedLength;
+}
+
+// Get preedit candidates of Imm32 and pass them to candidate-callback
+//
+static void getImmCandidates(_GLFWwindow* window)
+{
+    _GLFWpreedit* preedit = &window->preedit;
+    HIMC hIMC = ImmGetContext(window->win32.handle);
+    DWORD candidateListBytes = ImmGetCandidateListW(hIMC, 0, NULL, 0);
+
+    if (candidateListBytes == 0)
+    {
+        ImmReleaseContext(window->win32.handle, hIMC);
+        return;
+    }
+
+    {
+        int i;
+        int bufferCount = preedit->candidateBufferCount;
+        LPCANDIDATELIST candidateList = _glfw_calloc(candidateListBytes, 1);
+        if (candidateList == NULL)
+        {
+            ImmReleaseContext(window->win32.handle, hIMC);
+            return;
+        }
+        ImmGetCandidateListW(hIMC, 0, candidateList, candidateListBytes);
+        ImmReleaseContext(window->win32.handle, hIMC);
+
+        while ((DWORD) bufferCount < candidateList->dwCount + 1)
+            bufferCount = (bufferCount == 0) ? 1 : bufferCount * 2;
+        if (bufferCount != preedit->candidateBufferCount)
+        {
+            _GLFWpreeditcandidate* candidates =
+                _glfw_realloc(preedit->candidates,
+                              sizeof(_GLFWpreeditcandidate) * bufferCount);
+            if (candidates == NULL)
+            {
+                _glfw_free(candidateList);
+                return;
+            }
+            // `realloc` does not initialize the increased area with 0.
+            // This logic should be moved to a more appropriate place to share
+            // when other platforms support this feature.
+            for (i = preedit->candidateBufferCount; i < bufferCount; ++i)
+            {
+                candidates[i].text = NULL;
+                candidates[i].textCount = 0;
+                candidates[i].textBufferCount = 0;
+            }
+            preedit->candidates = candidates;
+            preedit->candidateBufferCount = bufferCount;
+        }
+
+        for (i = 0; (DWORD) i < candidateList->dwCount; ++i)
+            setCandidate(&preedit->candidates[i],
+                         (LPWSTR)((char*) candidateList + candidateList->dwOffset[i]));
+
+        preedit->candidateCount = candidateList->dwCount;
+        preedit->candidateSelection = candidateList->dwSelection;
+        preedit->candidatePageStart = candidateList->dwPageStart;
+        preedit->candidatePageSize = candidateList->dwPageSize;
+
+        _glfw_free(candidateList);
+    }
+
+    _glfwInputPreeditCandidate(window);
+}
+
+// Clear preedit candidates
+static void clearImmCandidate(_GLFWwindow* window)
+{
+    window->preedit.candidateCount = 0;
+    window->preedit.candidateSelection = 0;
+    window->preedit.candidatePageStart = 0;
+    window->preedit.candidatePageSize = 0;
+    _glfwInputPreeditCandidate(window);
+}
+
+// Get preedit texts of Imm32 and pass them to preedit-callback
+//
+static GLFWbool getImmPreedit(_GLFWwindow* window)
+{
+    _GLFWpreedit* preedit = &window->preedit;
+    HIMC hIMC = ImmGetContext(window->win32.handle);
+    // get preedit data sizes
+    LONG preeditBytes = ImmGetCompositionStringW(hIMC, GCS_COMPSTR, NULL, 0);
+    LONG attrBytes = ImmGetCompositionStringW(hIMC, GCS_COMPATTR, NULL, 0);
+    LONG clauseBytes = ImmGetCompositionStringW(hIMC, GCS_COMPCLAUSE, NULL, 0);
+    LONG cursorPos = ImmGetCompositionStringW(hIMC, GCS_CURSORPOS, NULL, 0);
+
+    if (preeditBytes > 0)
+    {
+        int textBufferCount = preedit->textBufferCount;
+        int blockBufferCount = preedit->blockSizesBufferCount;
+        int textLen = preeditBytes / sizeof(WCHAR);
+        LPWSTR buffer = _glfw_calloc(preeditBytes, 1);
+        LPSTR attributes = _glfw_calloc(attrBytes, 1);
+        DWORD* clauses = _glfw_calloc(clauseBytes, 1);
+
+        if (!buffer || (attrBytes > 0 && !attributes) || (clauseBytes > 0 && !clauses))
+        {
+            _glfw_free(buffer);
+            _glfw_free(attributes);
+            _glfw_free(clauses);
+            ImmReleaseContext(window->win32.handle, hIMC);
+            return GLFW_FALSE;
+        }
+
+        // get preedit data
+        ImmGetCompositionStringW(hIMC, GCS_COMPSTR, buffer, preeditBytes);
+        if (attributes)
+            ImmGetCompositionStringW(hIMC, GCS_COMPATTR, attributes, attrBytes);
+        if (clauses)
+            ImmGetCompositionStringW(hIMC, GCS_COMPCLAUSE, clauses, clauseBytes);
+
+        // realloc preedit text
+        while (textBufferCount < textLen + 1)
+            textBufferCount = (textBufferCount == 0) ? 1 : textBufferCount * 2;
+        if (textBufferCount != preedit->textBufferCount)
+        {
+            size_t bufsize = sizeof(unsigned int) * textBufferCount;
+            unsigned int* preeditText = _glfw_realloc(preedit->text,
+                                                      bufsize);
+
+            if (preeditText == NULL)
+            {
+                _glfw_free(buffer);
+                _glfw_free(attributes);
+                _glfw_free(clauses);
+                ImmReleaseContext(window->win32.handle, hIMC);
+                return GLFW_FALSE;
+            }
+            preedit->text = preeditText;
+            preedit->textBufferCount = textBufferCount;
+        }
+
+        // realloc blocks
+        preedit->blockSizesCount = clauses ? clauseBytes / sizeof(DWORD) - 1 : 1;
+        while (blockBufferCount < preedit->blockSizesCount)
+            blockBufferCount = (blockBufferCount == 0) ? 1 : blockBufferCount * 2;
+        if (blockBufferCount != preedit->blockSizesBufferCount)
+        {
+            size_t bufsize = sizeof(int) * blockBufferCount;
+            int* blocks = _glfw_realloc(preedit->blockSizes,
+                                        bufsize);
+
+            if (blocks == NULL)
+            {
+                _glfw_free(buffer);
+                _glfw_free(attributes);
+                _glfw_free(clauses);
+                ImmReleaseContext(window->win32.handle, hIMC);
+                return GLFW_FALSE;
+            }
+            preedit->blockSizes = blocks;
+            preedit->blockSizesBufferCount = blockBufferCount;
+        }
+
+        // store preedit text & block sizes
+        {
+            // Win32 API handles text data in UTF16, so we have to convert them
+            // to UTF32. Not only the encoding, but also the number of characters,
+            // the position of each block and the cursor.
+            int i;
+            uint32_t codepoint;
+            WCHAR highSurrogate = 0;
+            int convertedLength = 0;
+            int blockIndex = 0;
+            int currentBlockLength = 0;
+
+            // The last element of clauses is a block count, but
+            // text length is convenient.
+            if (clauses)
+                clauses[preedit->blockSizesCount] = textLen;
+
+            for (i = 0; i < textLen; i++)
+            {
+                if (clauses && clauses[blockIndex + 1] <= (DWORD) i)
+                {
+                    preedit->blockSizes[blockIndex++] = currentBlockLength;
+                    currentBlockLength = 0;
+                }
+
+                if (convertToUTF32FromUTF16(buffer[i],
+                                            &highSurrogate,
+                                            &codepoint))
+                {
+                    preedit->text[convertedLength++] = codepoint;
+                    currentBlockLength++;
+                }
+                else if ((LONG) i < cursorPos)
+                {
+                    // A high surrogate appears before cursorPos, so needs to
+                    // fix cursorPos on UTF16 for UTF32
+                    cursorPos--;
+                }
+            }
+            preedit->blockSizes[blockIndex] = currentBlockLength;
+            preedit->textCount = convertedLength;
+            preedit->text[convertedLength] = 0;
+            preedit->caretIndex = cursorPos;
+
+            preedit->focusedBlockIndex = 0;
+            if (attributes && clauses)
+            {
+                for (i = 0; i < preedit->blockSizesCount; i++)
+                {
+                    if (attributes[clauses[i]] == ATTR_TARGET_CONVERTED ||
+                        attributes[clauses[i]] == ATTR_TARGET_NOTCONVERTED)
+                    {
+                        preedit->focusedBlockIndex = i;
+                        break;
+                    }
+                }
+            }
+        }
+
+        _glfw_free(buffer);
+        _glfw_free(attributes);
+        _glfw_free(clauses);
+
+        _glfwInputPreedit(window);
+    }
+
+    ImmReleaseContext(window->win32.handle, hIMC);
+    return GLFW_TRUE;
+}
+
+// Clear peedit data
+//
+static void clearImmPreedit(_GLFWwindow* window)
+{
+    window->preedit.blockSizesCount = 0;
+    window->preedit.textCount = 0;
+    window->preedit.focusedBlockIndex = 0;
+    window->preedit.caretIndex = 0;
+    _glfwInputPreedit(window);
+}
+
+// Commit the result texts of Imm32 to character-callback
+//
+static GLFWbool commitImmResultStr(_GLFWwindow* window)
+{
+    HIMC hIMC;
+    LONG bytes;
+    uint32_t codepoint;
+    WCHAR highSurrogate = 0;
+
+    if (!window->callbacks.character)
+        return GLFW_FALSE;
+
+    hIMC = ImmGetContext(window->win32.handle);
+    // get preedit data sizes
+    bytes = ImmGetCompositionStringW(hIMC, GCS_RESULTSTR, NULL, 0);
+
+    if (bytes > 0)
+    {
+        int i;
+        int length = bytes / sizeof(WCHAR);
+        LPWSTR buffer = _glfw_calloc(bytes, 1);
+
+        // get preedit data
+        ImmGetCompositionStringW(hIMC, GCS_RESULTSTR, buffer, bytes);
+
+        for (i = 0; i < length; i++)
+        {
+            if (convertToUTF32FromUTF16(buffer[i],
+                                        &highSurrogate,
+                                        &codepoint))
+                window->callbacks.character((GLFWwindow*) window, codepoint);
+        }
+
+        _glfw_free(buffer);
+    }
+
+    ImmReleaseContext(window->win32.handle, hIMC);
+    return GLFW_TRUE;
+}
+
 // Window procedure for user-created windows
 //
 static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
@@ -553,6 +908,20 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM l
 
     switch (uMsg)
     {
+        case WM_IME_SETCONTEXT:
+        {
+            // To draw preedit text by an application side
+            if (lParam & ISC_SHOWUICOMPOSITIONWINDOW)
+                lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
+
+            if (_glfw.hints.init.managePreeditCandidate &&
+                (lParam & ISC_SHOWUICANDIDATEWINDOW))
+            {
+                lParam &= ~ISC_SHOWUICANDIDATEWINDOW;
+            }
+            break;
+        }
+
         case WM_MOUSEACTIVATE:
         {
             // HACK: Postpone cursor disabling when the window was activated by
@@ -658,27 +1027,11 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM l
         case WM_CHAR:
         case WM_SYSCHAR:
         {
-            if (wParam >= 0xd800 && wParam <= 0xdbff)
-                window->win32.highSurrogate = (WCHAR) wParam;
-            else
-            {
-                uint32_t codepoint = 0;
-
-                if (wParam >= 0xdc00 && wParam <= 0xdfff)
-                {
-                    if (window->win32.highSurrogate)
-                    {
-                        codepoint += (window->win32.highSurrogate - 0xd800) << 10;
-                        codepoint += (WCHAR) wParam - 0xdc00;
-                        codepoint += 0x10000;
-                    }
-                }
-                else
-                    codepoint = (WCHAR) wParam;
-
-                window->win32.highSurrogate = 0;
+            uint32_t codepoint;
+            if (convertToUTF32FromUTF16((WCHAR) wParam,
+                                        &window->win32.highSurrogate,
+                                        &codepoint))
                 _glfwInputChar(window, codepoint, getKeyMods(), uMsg != WM_SYSCHAR);
-            }
 
             if (uMsg == WM_SYSCHAR && window->win32.keymenu)
                 break;
@@ -796,6 +1149,54 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM l
             break;
         }
 
+        case WM_IME_COMPOSITION:
+        {
+            if (lParam & (GCS_RESULTSTR | GCS_COMPSTR))
+            {
+                if (lParam & GCS_RESULTSTR)
+                    commitImmResultStr(window);
+                if (lParam & GCS_COMPSTR)
+                    getImmPreedit(window);
+                return TRUE;
+            }
+            break;
+        }
+
+        case WM_IME_ENDCOMPOSITION:
+        {
+            clearImmPreedit(window);
+            // Usually clearing candidates in IMN_CLOSECANDIDATE is sufficient.
+            // However, some IME need it here, e.g. Google Japanese Input.
+            clearImmCandidate(window);
+            return TRUE;
+        }
+
+        case WM_IME_NOTIFY:
+        {
+            switch (wParam)
+            {
+                case IMN_SETOPENSTATUS:
+                {
+                    _glfwInputIMEStatus(window);
+                    return TRUE;
+                }
+
+                case IMN_OPENCANDIDATE:
+                case IMN_CHANGECANDIDATE:
+                {
+                    getImmCandidates(window);
+                    return TRUE;
+                }
+
+                case IMN_CLOSECANDIDATE:
+                {
+                    clearImmCandidate(window);
+                    return TRUE;
+                }
+            }
+            break;
+        }
+
         case WM_LBUTTONDOWN:
         case WM_RBUTTONDOWN:
         case WM_MBUTTONDOWN:
@@ -807,6 +1208,13 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM l
         {
             int i, button, action;
 
+            if (window->touchInput)
+            {
+                // Skip emulated button events when touch input is enabled
+                if ((GetMessageExtraInfo() & 0xffffff00) == 0xff515700)
+                    break;
+            }
+
             if (uMsg == WM_LBUTTONDOWN || uMsg == WM_LBUTTONUP)
                 button = GLFW_MOUSE_BUTTON_LEFT;
             else if (uMsg == WM_RBUTTONDOWN || uMsg == WM_RBUTTONUP)
@@ -890,7 +1298,9 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM l
             window->win32.lastCursorPosX = x;
             window->win32.lastCursorPosY = y;
 
-            return 0;
+            // NOTE: WM_MOUSEMOVE messages must be passed on to DefWindowProc
+            //       for WM_TOUCH messages to be emitted
+            break;
         }
 
         case WM_INPUT:
@@ -1116,6 +1526,60 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM l
             return 0;
         }
 
+        case WM_TOUCH:
+        {
+            TOUCHINPUT* inputs;
+            UINT count = LOWORD(wParam);
+
+            if (!_glfw.win32.touch.available)
+                return 0;
+
+            inputs = (TOUCHINPUT*) malloc(sizeof(TOUCHINPUT) * count);
+
+            if (GetTouchInputInfo((HTOUCHINPUT) lParam,
+                                        count, inputs, sizeof(TOUCHINPUT)))
+            {
+                UINT i;
+                int width, height, xpos, ypos;
+
+                _glfwGetWindowSizeWin32(window, &width, &height);
+                _glfwGetWindowPosWin32(window, &xpos, &ypos);
+
+                for (i = 0;  i < count;  i++)
+                {
+                    int action;
+                    POINT pos;
+
+                    pos.x = TOUCH_COORD_TO_PIXEL(inputs[i].x) - xpos;
+                    pos.y = TOUCH_COORD_TO_PIXEL(inputs[i].y) - ypos;
+
+                    // Discard any points that lie outside of the client area
+                    if (pos.x < 0 || pos.x >= width ||
+                        pos.y < 0 || pos.y >= height)
+                    {
+                        continue;
+                    }
+
+                    if (inputs[i].dwFlags & TOUCHEVENTF_DOWN)
+                        action = GLFW_PRESS;
+                    else if (inputs[i].dwFlags & TOUCHEVENTF_UP)
+                        action = GLFW_RELEASE;
+                    else
+                        action = GLFW_MOVE;
+
+                    _glfwInputTouch(window,
+                                    (int) inputs[i].dwID, action,
+                                    inputs[i].x / 100.0 - xpos,
+                                    inputs[i].y / 100.0 - ypos);
+                }
+
+                CloseTouchInputHandle((HTOUCHINPUT) lParam);
+            }
+
+            free(inputs);
+            break;
+        }
+
         case WM_PAINT:
         {
             _glfwInputWindowDamage(window);
@@ -1832,11 +2296,18 @@ void _glfwSetWindowMonitorWin32(_GLFWwindow* window,
         acquireMonitor(window);
 
         GetMonitorInfoW(window->monitor->win32.handle, &mi);
+        // On Win32, the window behaves in a special way when the window covers the screen exactly.
+        // In this case, the window is a strong exclusive exceeding HWND_TOPMOST and it doen't
+        // display OS notifications such as the sound volumn changed.
+        // This behavior can be deactivated by shifting the size slightly.
+        // This is especially necessary for the IME(Input Method Editor/Engine) to display properly.
+        // This can also effect transparency to fullscreen.
         SetWindowPos(window->win32.handle, HWND_TOPMOST,
                      mi.rcMonitor.left,
                      mi.rcMonitor.top,
                      mi.rcMonitor.right - mi.rcMonitor.left,
-                     mi.rcMonitor.bottom - mi.rcMonitor.top,
+                     _glfw.hints.window.softFullscreen ? mi.rcMonitor.bottom - mi.rcMonitor.top + 1
+                                                       : mi.rcMonitor.bottom - mi.rcMonitor.top,
                      flags);
     }
     else
@@ -2030,6 +2501,22 @@ GLFWbool _glfwRawMouseMotionSupportedWin32(void)
     return GLFW_TRUE;
 }
 
+void _glfwSetTouchInputWin32(_GLFWwindow* window, int enabled)
+{
+    if (!_glfw.win32.touch.available)
+        return;
+
+    if (enabled)
+        RegisterTouchWindow(window->win32.handle, 0);
+    else
+        UnregisterTouchWindow(window->win32.handle);
+}
+
+GLFWbool _glfwTouchInputSupportedWin32(void)
+{
+    return _glfw.win32.touch.available;
+}
+
 void _glfwPollEventsWin32(void)
 {
     MSG msg;
@@ -2373,6 +2860,48 @@ const char* _glfwGetClipboardStringWin32(void)
     return _glfw.win32.clipboardString;
 }
 
+void _glfwUpdatePreeditCursorRectangleWin32(_GLFWwindow* window)
+{
+    _GLFWpreedit* preedit = &window->preedit;
+    HWND hWnd = window->win32.handle;
+    HIMC hIMC = ImmGetContext(hWnd);
+
+    int x = preedit->cursorPosX;
+    int y = preedit->cursorPosY;
+    int w = preedit->cursorWidth;
+    int h = preedit->cursorHeight;
+    CANDIDATEFORM excludeRect = { 0, CFS_EXCLUDE, { x, y }, { x, y, x + w, y + h } };
+
+    ImmSetCandidateWindow(hIMC, &excludeRect);
+
+    ImmReleaseContext(hWnd, hIMC);
+}
+
+void _glfwResetPreeditTextWin32(_GLFWwindow* window)
+{
+    HWND hWnd = window->win32.handle;
+    HIMC hIMC = ImmGetContext(hWnd);
+    ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
+    ImmReleaseContext(hWnd, hIMC);
+}
+
+void _glfwSetIMEStatusWin32(_GLFWwindow* window, int active)
+{
+    HWND hWnd = window->win32.handle;
+    HIMC hIMC = ImmGetContext(hWnd);
+    ImmSetOpenStatus(hIMC, active ? TRUE : FALSE);
+    ImmReleaseContext(hWnd, hIMC);
+}
+
+int _glfwGetIMEStatusWin32(_GLFWwindow* window)
+{
+    HWND hWnd = window->win32.handle;
+    HIMC hIMC = ImmGetContext(hWnd);
+    BOOL result = ImmGetOpenStatus(hIMC);
+    ImmReleaseContext(hWnd, hIMC);
+    return result ? GLFW_TRUE : GLFW_FALSE;
+}
+
 EGLenum _glfwGetEGLPlatformWin32(EGLint** attribs)
 {
     if (_glfw.egl.ANGLE_platform_angle)
diff --git a/src/window.c b/src/window.c
index 1c8519ff74..08757ed739 100644
--- a/src/window.c
+++ b/src/window.c
@@ -245,6 +245,11 @@ GLFWAPI GLFWwindow* glfwCreateWindow(int width, int height,
     window->numer       = GLFW_DONT_CARE;
     window->denom       = GLFW_DONT_CARE;
 
+    window->preedit.cursorPosX = 0;
+    window->preedit.cursorPosY = height;
+    window->preedit.cursorWidth = 0;
+    window->preedit.cursorHeight = 0;
+
     if (!_glfw.platform.createWindow(window, &wndconfig, &ctxconfig, &fbconfig))
     {
         glfwDestroyWindow((GLFWwindow*) window);
@@ -267,15 +272,18 @@ void glfwDefaultWindowHints(void)
 
     // The default is a focused, visible, resizable window with decorations
     memset(&_glfw.hints.window, 0, sizeof(_glfw.hints.window));
-    _glfw.hints.window.resizable    = GLFW_TRUE;
-    _glfw.hints.window.visible      = GLFW_TRUE;
-    _glfw.hints.window.decorated    = GLFW_TRUE;
-    _glfw.hints.window.focused      = GLFW_TRUE;
-    _glfw.hints.window.autoIconify  = GLFW_TRUE;
-    _glfw.hints.window.centerCursor = GLFW_TRUE;
-    _glfw.hints.window.focusOnShow  = GLFW_TRUE;
-    _glfw.hints.window.xpos         = GLFW_ANY_POSITION;
-    _glfw.hints.window.ypos         = GLFW_ANY_POSITION;
+    _glfw.hints.window.resizable      = GLFW_TRUE;
+    _glfw.hints.window.visible        = GLFW_TRUE;
+    _glfw.hints.window.decorated      = GLFW_TRUE;
+    _glfw.hints.window.focused        = GLFW_TRUE;
+    _glfw.hints.window.autoIconify    = GLFW_TRUE;
+    _glfw.hints.window.centerCursor   = GLFW_TRUE;
+    _glfw.hints.window.focusOnShow    = GLFW_TRUE;
+    _glfw.hints.window.xpos           = GLFW_ANY_POSITION;
+    _glfw.hints.window.ypos           = GLFW_ANY_POSITION;
+    // The default is hard-fullscreen, which is exclusive.
+    // Soft-fullscreen is not exclusive and is suitable for applications such as text-editors.
+    _glfw.hints.window.softFullscreen = GLFW_FALSE;
 
     // The default is 24 bits of color, 24 bits of depth and 8 bits of stencil,
     // double buffered
@@ -397,6 +405,9 @@ GLFWAPI void glfwWindowHint(int hint, int value)
         case GLFW_MOUSE_PASSTHROUGH:
             _glfw.hints.window.mousePassthrough = value ? GLFW_TRUE : GLFW_FALSE;
             return;
+        case GLFW_SOFT_FULLSCREEN:
+            _glfw.hints.window.softFullscreen = value ? GLFW_TRUE : GLFW_FALSE;
+            return;
         case GLFW_CLIENT_API:
             _glfw.hints.context.client = value;
             return;
@@ -494,6 +505,11 @@ GLFWAPI void glfwDestroyWindow(GLFWwindow* handle)
         *prev = window->next;
     }
 
+    // Clear memory for preedit text
+    if (window->preedit.text)
+        _glfw_free(window->preedit.text);
+    if (window->preedit.blockSizes)
+        _glfw_free(window->preedit.blockSizes);
     _glfw_free(window);
 }
 
diff --git a/src/wl_init.c b/src/wl_init.c
index 0ec65900c9..9117ccc7c6 100644
--- a/src/wl_init.c
+++ b/src/wl_init.c
@@ -49,6 +49,8 @@
 #include "wayland-relative-pointer-unstable-v1-client-protocol.h"
 #include "wayland-pointer-constraints-unstable-v1-client-protocol.h"
 #include "wayland-idle-inhibit-unstable-v1-client-protocol.h"
+#include "wayland-text-input-unstable-v1-client-protocol.h"
+#include "wayland-text-input-unstable-v3-client-protocol.h"
 
 // NOTE: Versions of wayland-scanner prior to 1.17.91 named every global array of
 //       wl_interface pointers 'types', making it impossible to combine several unmodified
@@ -83,6 +85,14 @@
 #include "wayland-idle-inhibit-unstable-v1-client-protocol-code.h"
 #undef types
 
+#define types _glfw_text_input_v1_types
+#include "wayland-text-input-unstable-v1-client-protocol-code.h"
+#undef types
+
+#define types _glfw_text_input_v3_types
+#include "wayland-text-input-unstable-v3-client-protocol-code.h"
+#undef types
+
 static void wmBaseHandlePing(void* userData,
                              struct xdg_wm_base* wmBase,
                              uint32_t serial)
@@ -179,6 +189,20 @@ static void registryHandleGlobal(void* userData,
                              &zwp_idle_inhibit_manager_v1_interface,
                              1);
     }
+    else if (strcmp(interface, "zwp_text_input_manager_v1") == 0)
+    {
+        _glfw.wl.textInputManagerV1 =
+            wl_registry_bind(registry, name,
+                             &zwp_text_input_manager_v1_interface,
+                             1);
+    }
+    else if (strcmp(interface, "zwp_text_input_manager_v3") == 0)
+    {
+        _glfw.wl.textInputManagerV3 =
+            wl_registry_bind(registry, name,
+                             &zwp_text_input_manager_v3_interface,
+                             1);
+    }
 }
 
 static void registryHandleGlobalRemove(void* userData,
@@ -423,6 +447,12 @@ GLFWbool _glfwConnectWayland(int platformID, _GLFWplatform* platform)
         _glfwGetKeyScancodeWayland,
         _glfwSetClipboardStringWayland,
         _glfwGetClipboardStringWayland,
+        _glfwUpdatePreeditCursorRectangleWayland,
+        _glfwResetPreeditTextWayland,
+        _glfwSetIMEStatusWayland,
+        _glfwGetIMEStatusWayland,
+         _glfwSetTouchInputWayland,
+        _glfwTouchInputSupportedWayland,
 #if defined(GLFW_BUILD_LINUX_JOYSTICK)
         _glfwInitJoysticksLinux,
         _glfwTerminateJoysticksLinux,
@@ -928,6 +958,10 @@ void _glfwTerminateWayland(void)
         zwp_pointer_constraints_v1_destroy(_glfw.wl.pointerConstraints);
     if (_glfw.wl.idleInhibitManager)
         zwp_idle_inhibit_manager_v1_destroy(_glfw.wl.idleInhibitManager);
+    if (_glfw.wl.textInputManagerV1)
+        zwp_text_input_manager_v1_destroy(_glfw.wl.textInputManagerV1);
+    if (_glfw.wl.textInputManagerV3)
+        zwp_text_input_manager_v3_destroy(_glfw.wl.textInputManagerV3);
     if (_glfw.wl.registry)
         wl_registry_destroy(_glfw.wl.registry);
     if (_glfw.wl.display)
diff --git a/src/wl_platform.h b/src/wl_platform.h
index d00e28fe5c..f4c351e183 100644
--- a/src/wl_platform.h
+++ b/src/wl_platform.h
@@ -412,6 +412,13 @@ typedef struct _GLFWwindowWayland
         _GLFWdecorationWayland             top, left, right, bottom;
         _GLFWdecorationSideWayland         focus;
     } decorations;
+
+    struct zwp_text_input_v1* textInputV1;
+    struct zwp_text_input_v3* textInputV3;
+    struct {
+        char* preeditText;
+        char* commitTextOnReset;
+    } textInputV1Context;
 } _GLFWwindowWayland;
 
 // Wayland-specific global data
@@ -434,6 +441,8 @@ typedef struct _GLFWlibraryWayland
     struct zwp_relative_pointer_manager_v1* relativePointerManager;
     struct zwp_pointer_constraints_v1*      pointerConstraints;
     struct zwp_idle_inhibit_manager_v1*     idleInhibitManager;
+    struct zwp_text_input_manager_v1*       textInputManagerV1;
+    struct zwp_text_input_manager_v3*       textInputManagerV3;
 
     _GLFWofferWayland*          offers;
     unsigned int                offerCount;
@@ -651,6 +660,9 @@ void _glfwWaitEventsWayland(void);
 void _glfwWaitEventsTimeoutWayland(double timeout);
 void _glfwPostEmptyEventWayland(void);
 
+void _glfwSetTouchInputWayland(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwTouchInputSupportedWayland(void);
+
 void _glfwGetCursorPosWayland(_GLFWwindow* window, double* xpos, double* ypos);
 void _glfwSetCursorPosWayland(_GLFWwindow* window, double xpos, double ypos);
 void _glfwSetCursorModeWayland(_GLFWwindow* window, int mode);
@@ -663,6 +675,11 @@ void _glfwSetCursorWayland(_GLFWwindow* window, _GLFWcursor* cursor);
 void _glfwSetClipboardStringWayland(const char* string);
 const char* _glfwGetClipboardStringWayland(void);
 
+void _glfwUpdatePreeditCursorRectangleWayland(_GLFWwindow* window);
+void _glfwResetPreeditTextWayland(_GLFWwindow* window);
+void _glfwSetIMEStatusWayland(_GLFWwindow* window, int active);
+int _glfwGetIMEStatusWayland(_GLFWwindow* window);
+
 EGLenum _glfwGetEGLPlatformWayland(EGLint** attribs);
 EGLNativeDisplayType _glfwGetEGLNativeDisplayWayland(void);
 EGLNativeWindowType _glfwGetEGLNativeWindowWayland(_GLFWwindow* window);
diff --git a/src/wl_window.c b/src/wl_window.c
index 7c5098963d..5296d19864 100644
--- a/src/wl_window.c
+++ b/src/wl_window.c
@@ -50,6 +50,8 @@
 #include "wayland-relative-pointer-unstable-v1-client-protocol.h"
 #include "wayland-pointer-constraints-unstable-v1-client-protocol.h"
 #include "wayland-idle-inhibit-unstable-v1-client-protocol.h"
+#include "wayland-text-input-unstable-v1-client-protocol.h"
+#include "wayland-text-input-unstable-v3-client-protocol.h"
 
 #define GLFW_BORDER_SIZE    4
 #define GLFW_CAPTION_HEIGHT 24
@@ -483,6 +485,22 @@ static void releaseMonitor(_GLFWwindow* window)
     }
 }
 
+static void activateTextInputV1(_GLFWwindow* window)
+{
+    if (!window->wl.textInputV1)
+        return;
+    zwp_text_input_v1_show_input_panel(window->wl.textInputV1);
+    zwp_text_input_v1_activate(window->wl.textInputV1, _glfw.wl.seat, window->wl.surface);
+}
+
+static void deactivateTextInputV1(_GLFWwindow* window)
+{
+    if (!window->wl.textInputV1)
+        return;
+    zwp_text_input_v1_hide_input_panel(window->wl.textInputV1);
+    zwp_text_input_v1_deactivate(window->wl.textInputV1, _glfw.wl.seat);
+}
+
 static void xdgToplevelHandleConfigure(void* userData,
                                        struct xdg_toplevel* toplevel,
                                        int32_t width,
@@ -510,6 +528,7 @@ static void xdgToplevelHandleConfigure(void* userData,
                 break;
             case XDG_TOPLEVEL_STATE_ACTIVATED:
                 window->wl.pending.activated = GLFW_TRUE;
+                activateTextInputV1(window);
                 break;
         }
     }
@@ -1423,6 +1442,12 @@ static void pointerHandleButton(void* userData,
 
     if (!window)
         return;
+
+    // On weston, pressing the title bar will cause leave event and never emit
+    // enter event even though back to content area by pressing mouse button
+    // just after it. So activate it here explicitly.
+    activateTextInputV1(window);
+
     if (button == BTN_LEFT)
     {
         switch (window->wl.decorations.focus)
@@ -2004,6 +2029,376 @@ void _glfwAddDataDeviceListenerWayland(struct wl_data_device* device)
     wl_data_device_add_listener(device, &dataDeviceListener, NULL);
 }
 
+// Callbacks for text_input_unstable_v3 protocol.
+//
+// This protocol is widely supported by major desktop environments such as GNOME
+// or KDE.
+//
+static void textInputV3Enter(void* data,
+                             struct zwp_text_input_v3* textInputV3,
+                             struct wl_surface* surface)
+{
+    zwp_text_input_v3_enable(textInputV3);
+    zwp_text_input_v3_commit(textInputV3);
+}
+
+static void textInputV3Reset(_GLFWwindow* window)
+{
+    _GLFWpreedit* preedit = &window->preedit;
+
+    preedit->textCount = 0;
+    preedit->blockSizesCount = 0;
+    preedit->focusedBlockIndex = 0;
+    preedit->caretIndex = 0;
+
+    _glfwInputPreedit(window);
+}
+
+static void textInputV3Leave(void* data,
+                             struct zwp_text_input_v3* textInputV3,
+                             struct wl_surface* surface)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+    zwp_text_input_v3_disable(textInputV3);
+    zwp_text_input_v3_commit(textInputV3);
+
+    // Although this should be handled by IM via preedit callback, it seems that
+    // the behavior varies depending on implemention. It's cleared by IM on
+    // Ubuntu 22.04 but not cleared on Ubuntu 20.04.
+    textInputV3Reset(window);
+}
+
+static void textInputV3PreeditString(void* data,
+                                     struct zwp_text_input_v3* textInputV3,
+                                     const char* text,
+                                     int32_t cursorBegin,
+                                     int32_t cursorEnd)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+    _GLFWpreedit* preedit = &window->preedit;
+    const char* cur = text;
+    unsigned int cursorLength = 0;
+
+    preedit->textCount = 0;
+    preedit->blockSizesCount = 0;
+    preedit->focusedBlockIndex = 0;
+    preedit->caretIndex = 0;
+
+    // Store preedit text
+    while (cur && *cur)
+    {
+        uint32_t codepoint = _glfwDecodeUTF8(&cur);
+
+        ++preedit->textCount;
+
+        if (cur == text + cursorBegin)
+            preedit->caretIndex = preedit->textCount;
+        if (cursorBegin != cursorEnd && cur == text + cursorEnd)
+            cursorLength = preedit->textCount - cursorBegin;
+
+        if (preedit->textBufferCount < preedit->textCount + 1)
+        {
+            int bufSize = preedit->textBufferCount;
+
+            while (bufSize < preedit->textCount + 1)
+                bufSize = (bufSize == 0) ? 1 : bufSize * 2;
+            preedit->text = _glfw_realloc(preedit->text,
+                                          sizeof(unsigned int) * bufSize);
+            if (!preedit->text)
+                return;
+            preedit->textBufferCount = bufSize;
+        }
+        preedit->text[preedit->textCount - 1] = codepoint;
+    }
+    if (preedit->text)
+        preedit->text[preedit->textCount] = 0;
+
+    // Store preedit blocks
+    if (preedit->textCount)
+    {
+        int* blocks = preedit->blockSizes;
+        int blockCount = preedit->blockSizesCount;
+        int cursorPos = preedit->caretIndex;
+        int textCount = preedit->textCount;
+
+        if (!preedit->blockSizes)
+        {
+            int bufSize = 3;
+
+            preedit->blockSizesBufferCount = bufSize;
+            preedit->blockSizes = _glfw_calloc(sizeof(int), bufSize);
+            if (!preedit->blockSizes)
+                return;
+            blocks = preedit->blockSizes;
+        }
+
+        if (cursorLength && cursorPos)
+            blocks[blockCount++] = cursorPos;
+
+        preedit->focusedBlockIndex = blockCount;
+        blocks[blockCount++] = cursorLength ? cursorLength : textCount;
+
+        if (cursorLength && cursorPos + cursorLength != textCount)
+            blocks[blockCount++] = textCount - cursorPos - cursorLength;
+
+        preedit->blockSizesCount = blockCount;
+    }
+}
+
+static void textInputV3CommitString(void* data,
+                                    struct zwp_text_input_v3* textInputV3,
+                                    const char* text)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+    const char* cur = text;
+
+    while (cur && *cur)
+    {
+        uint32_t codepoint = _glfwDecodeUTF8(&cur);
+        window->callbacks.character((GLFWwindow*) window, codepoint);
+    }
+}
+
+static void textInputV3DeleteSurroundingText(void* data,
+                                             struct zwp_text_input_v3* textInputV3,
+                                             uint32_t beforeLength,
+                                             uint32_t afterLength)
+{
+}
+
+static void textInputV3Done(void* data,
+                            struct zwp_text_input_v3* textInputV3,
+                            uint32_t serial)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+    _glfwUpdatePreeditCursorRectangleWayland(window);
+    _glfwInputPreedit(window);
+}
+
+static const struct zwp_text_input_v3_listener textInputV3Listener =
+{
+    textInputV3Enter,
+    textInputV3Leave,
+    textInputV3PreeditString,
+    textInputV3CommitString,
+    textInputV3DeleteSurroundingText,
+    textInputV3Done
+};
+
+// Callbacks for text_input_unstable_v1 protocol
+//
+// This protocol isn't so popular but Weston which is the reference Wayland
+// implementation supports only this protocol and doesn't support
+// text_input_unstable_v3.
+//
+static void textInputV1Enter(void* data,
+                             struct zwp_text_input_v1* textInputV1,
+                             struct wl_surface* surface)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+    activateTextInputV1(window);
+}
+
+static void textInputV1Reset(_GLFWwindow* window)
+{
+    _GLFWpreedit* preedit = &window->preedit;
+
+    preedit->textCount = 0;
+    preedit->blockSizesCount = 0;
+    preedit->focusedBlockIndex = 0;
+    preedit->caretIndex = 0;
+
+    _glfw_free(window->wl.textInputV1Context.preeditText);
+    _glfw_free(window->wl.textInputV1Context.commitTextOnReset);
+    window->wl.textInputV1Context.preeditText = NULL;
+    window->wl.textInputV1Context.commitTextOnReset = NULL;
+
+    _glfwInputPreedit(window);
+}
+
+static void textInputV1Leave(void* data,
+                             struct zwp_text_input_v1* textInputV1)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+    char* commitText = window->wl.textInputV1Context.commitTextOnReset;
+
+    textInputV3CommitString(data, NULL, commitText);
+    textInputV1Reset(window);
+    deactivateTextInputV1(window);
+}
+
+static void textInputV1ModifiersMap(void* data,
+                                    struct zwp_text_input_v1* textInputV1,
+                                    struct wl_array* map)
+{
+}
+
+static void textInputV1InputPanelState(void* data,
+                                       struct zwp_text_input_v1* textInputV1,
+                                       uint32_t state)
+{
+}
+
+static void textInputV1PreeditString(void* data,
+                                     struct zwp_text_input_v1* textInputV1,
+                                     uint32_t serial,
+                                     const char* text,
+                                     const char* commit)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+
+    _glfw_free(window->wl.textInputV1Context.preeditText);
+    _glfw_free(window->wl.textInputV1Context.commitTextOnReset);
+    window->wl.textInputV1Context.preeditText = strdup(text);
+    window->wl.textInputV1Context.commitTextOnReset = strdup(commit);
+
+    textInputV3PreeditString(data, NULL, text, 0, 0);
+    _glfwInputPreedit(window);
+}
+
+static void textInputV1PreeditStyling(void* data,
+                                      struct zwp_text_input_v1* textInputV1,
+                                      uint32_t index,
+                                      uint32_t length,
+                                      uint32_t style)
+{
+}
+
+static void textInputV1PreeditCursor(void* data,
+                                     struct zwp_text_input_v1* textInputV1,
+                                     int32_t index)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+    _GLFWpreedit* preedit = &window->preedit;
+    const char* text = window->wl.textInputV1Context.preeditText;
+    const char* cur = text;
+
+    preedit->caretIndex = 0;
+    if (index <= 0 || preedit->textCount == 0)
+        return;
+
+    while (cur && *cur)
+    {
+        _glfwDecodeUTF8(&cur);
+        ++preedit->caretIndex;
+        if (cur >= text + index)
+            break;
+        if (preedit->caretIndex > preedit->textCount)
+            break;
+    }
+}
+
+static void textInputV1CommitString(void* data,
+                                    struct zwp_text_input_v1* textInputV1,
+                                    uint32_t serial,
+                                    const char* text)
+{
+    _GLFWwindow* window = (_GLFWwindow*) data;
+
+    textInputV1Reset(window);
+    textInputV3CommitString(data, NULL, text);
+}
+
+static void textInputV1CursorPosition(void* data,
+                                      struct zwp_text_input_v1* textInputV1,
+                                      int32_t index,
+                                      int32_t anchor)
+{
+    // It's for surrounding text feature which isn't supported by GLFW.
+}
+
+static void textInputV1DeleteSurroundingText(void* data,
+                                             struct zwp_text_input_v1* textInputV1,
+                                             int32_t index,
+                                             uint32_t length)
+{
+}
+
+static void textInputV1Keysym(void* data,
+                              struct zwp_text_input_v1* textInputV1,
+                              uint32_t serial,
+                              uint32_t time,
+                              uint32_t sym,
+                              uint32_t state,
+                              uint32_t modifiers)
+{
+    uint32_t scancode;
+
+    // This code supports only weston-keyboard because we aren't aware
+    // of any other input methods that actually support this API.
+    // Supporting all keysyms is overkill for now.
+
+    switch (sym)
+    {
+        case XKB_KEY_Left:
+            scancode = KEY_LEFT;
+            break;
+        case XKB_KEY_Right:
+            scancode = KEY_RIGHT;
+            break;
+        case XKB_KEY_Up:
+            scancode = KEY_UP;
+            break;
+        case XKB_KEY_Down:
+            scancode = KEY_DOWN;
+            break;
+        case XKB_KEY_BackSpace:
+            scancode = KEY_BACKSPACE;
+            break;
+        case XKB_KEY_Tab:
+            scancode = KEY_TAB;
+            break;
+        case XKB_KEY_KP_Enter:
+            scancode = KEY_KPENTER;
+            break;
+        case XKB_KEY_Return:
+            scancode = KEY_ENTER;
+            break;
+        default:
+            return;
+    }
+
+    _glfw.wl.xkb.modifiers = modifiers;
+
+    keyboardHandleKey(data,
+                      _glfw.wl.keyboard,
+                      serial,
+                      time,
+                      scancode,
+                      state);
+}
+
+static void textInputV1Language(void* data,
+                                struct zwp_text_input_v1* textInputV1,
+                                uint32_t serial,
+                                const char* language)
+{
+}
+
+static void textInputV1TextDirection(void* data,
+                                     struct zwp_text_input_v1* textInputV1,
+                                     uint32_t serial,
+                                     uint32_t direction)
+{
+}
+
+static const struct zwp_text_input_v1_listener textInputV1Listener =
+{
+    textInputV1Enter,
+    textInputV1Leave,
+    textInputV1ModifiersMap,
+    textInputV1InputPanelState,
+    textInputV1PreeditString,
+    textInputV1PreeditStyling,
+    textInputV1PreeditCursor,
+    textInputV1CommitString,
+    textInputV1CursorPosition,
+    textInputV1DeleteSurroundingText,
+    textInputV1Keysym,
+    textInputV1Language,
+    textInputV1TextDirection
+};
+
 
 //////////////////////////////////////////////////////////////////////////
 //////                       GLFW platform API                      //////
@@ -2058,6 +2453,21 @@ GLFWbool _glfwCreateWindowWayland(_GLFWwindow* window,
             return GLFW_FALSE;
     }
 
+    if (_glfw.wl.textInputManagerV3)
+    {
+        window->wl.textInputV3 =
+            zwp_text_input_manager_v3_get_text_input(_glfw.wl.textInputManagerV3, _glfw.wl.seat);
+        zwp_text_input_v3_add_listener(window->wl.textInputV3,
+                                       &textInputV3Listener, window);
+    }
+    else if (_glfw.wl.textInputManagerV1)
+    {
+        window->wl.textInputV1 =
+            zwp_text_input_manager_v1_create_text_input(_glfw.wl.textInputManagerV1);
+        zwp_text_input_v1_add_listener(window->wl.textInputV1,
+                                       &textInputV1Listener, window);
+    }
+
     return GLFW_TRUE;
 }
 
@@ -2069,6 +2479,15 @@ void _glfwDestroyWindowWayland(_GLFWwindow* window)
     if (window == _glfw.wl.keyboardFocus)
         _glfw.wl.keyboardFocus = NULL;
 
+    if (window->wl.textInputV1) {
+        zwp_text_input_v1_destroy(window->wl.textInputV1);
+        _glfw_free(window->wl.textInputV1Context.preeditText);
+        _glfw_free(window->wl.textInputV1Context.commitTextOnReset);
+    }
+
+    if (window->wl.textInputV3)
+        zwp_text_input_v3_destroy(window->wl.textInputV3);
+
     if (window->wl.idleInhibitor)
         zwp_idle_inhibitor_v1_destroy(window->wl.idleInhibitor);
 
@@ -2530,6 +2949,17 @@ void _glfwPostEmptyEventWayland(void)
     flushDisplay();
 }
 
+void _glfwSetTouchInputWayland(_GLFWwindow *window, GLFWbool enabled)
+{
+    _glfwInputError(GLFW_FEATURE_UNIMPLEMENTED,
+                    "Wayland: Touch input not yet implemented");
+}
+
+GLFWbool _glfwTouchInputSupportedWayland(void)
+{
+    return GLFW_FALSE;
+}
+
 void _glfwGetCursorPosWayland(_GLFWwindow* window, double* xpos, double* ypos)
 {
     if (xpos)
@@ -3063,6 +3493,36 @@ const char* _glfwGetClipboardStringWayland(void)
     return _glfw.wl.clipboardString;
 }
 
+void _glfwUpdatePreeditCursorRectangleWayland(_GLFWwindow* window)
+{
+    _GLFWpreedit* preedit = &window->preedit;
+    int x = preedit->cursorPosX;
+    int y = preedit->cursorPosY;
+    int w = preedit->cursorWidth;
+    int h = preedit->cursorHeight;
+
+    if (window->wl.textInputV3)
+    {
+        zwp_text_input_v3_set_cursor_rectangle(window->wl.textInputV3, x, y, w, h);
+        zwp_text_input_v3_commit(window->wl.textInputV3);
+    }
+    else if (window->wl.textInputV1)
+        zwp_text_input_v1_set_cursor_rectangle(window->wl.textInputV1, x, y, w, h);
+}
+
+void _glfwResetPreeditTextWayland(_GLFWwindow* window)
+{
+}
+
+void _glfwSetIMEStatusWayland(_GLFWwindow* window, int active)
+{
+}
+
+int _glfwGetIMEStatusWayland(_GLFWwindow* window)
+{
+    return GLFW_FALSE;
+}
+
 EGLenum _glfwGetEGLPlatformWayland(EGLint** attribs)
 {
     if (_glfw.egl.EXT_platform_base && _glfw.egl.EXT_platform_wayland)
diff --git a/src/x11_init.c b/src/x11_init.c
index a0100f2fc1..40513a709c 100644
--- a/src/x11_init.c
+++ b/src/x11_init.c
@@ -447,9 +447,14 @@ static GLFWbool hasUsableInputMethodStyle(void)
     if (XGetIMValues(_glfw.x11.im, XNQueryInputStyle, &styles, NULL) != NULL)
         return GLFW_FALSE;
 
+    if (_glfw.hints.init.x11.onTheSpotIMStyle)
+        _glfw.x11.imStyle = STYLE_ONTHESPOT;
+    else
+        _glfw.x11.imStyle = STYLE_OVERTHESPOT;
+
     for (unsigned int i = 0;  i < styles->count_styles;  i++)
     {
-        if (styles->supported_styles[i] == (XIMPreeditNothing | XIMStatusNothing))
+        if (styles->supported_styles[i] == _glfw.x11.imStyle)
         {
             found = GLFW_TRUE;
             break;
@@ -1184,6 +1189,12 @@ GLFWbool _glfwConnectX11(int platformID, _GLFWplatform* platform)
         _glfwGetKeyScancodeX11,
         _glfwSetClipboardStringX11,
         _glfwGetClipboardStringX11,
+        _glfwUpdatePreeditCursorRectangleX11,
+        _glfwResetPreeditTextX11,
+        _glfwSetIMEStatusX11,
+        _glfwGetIMEStatusX11,
+        _glfwSetTouchInputX11,
+        _glfwTouchInputSupportedX11,
 #if defined(GLFW_BUILD_LINUX_JOYSTICK)
         _glfwInitJoysticksLinux,
         _glfwTerminateJoysticksLinux,
@@ -1453,6 +1464,8 @@ int _glfwInitX11(void)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XSetErrorHandler");
     _glfw.x11.xlib.SetICFocus = (PFN_XSetICFocus)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XSetICFocus");
+    _glfw.x11.xlib.SetICValues = (PFN_XSetICValues)
+        _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XSetICValues");
     _glfw.x11.xlib.SetIMValues = (PFN_XSetIMValues)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XSetIMValues");
     _glfw.x11.xlib.SetInputFocus = (PFN_XSetInputFocus)
@@ -1483,6 +1496,8 @@ int _glfwInitX11(void)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XUnmapWindow");
     _glfw.x11.xlib.UnsetICFocus = (PFN_XUnsetICFocus)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XUnsetICFocus");
+    _glfw.x11.xlib.VaCreateNestedList = (PFN_XVaCreateNestedList)
+        _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XVaCreateNestedList");
     _glfw.x11.xlib.VisualIDFromVisual = (PFN_XVisualIDFromVisual)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XVisualIDFromVisual");
     _glfw.x11.xlib.WarpPointer = (PFN_XWarpPointer)
@@ -1515,6 +1530,8 @@ int _glfwInitX11(void)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XrmUniqueQuark");
     _glfw.x11.xlib.UnregisterIMInstantiateCallback = (PFN_XUnregisterIMInstantiateCallback)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XUnregisterIMInstantiateCallback");
+    _glfw.x11.xlib.mbResetIC = (PFN_XmbResetIC)
+        _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XmbResetIC");
     _glfw.x11.xlib.utf8LookupString = (PFN_Xutf8LookupString)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "Xutf8LookupString");
     _glfw.x11.xlib.utf8SetWMProperties = (PFN_Xutf8SetWMProperties)
diff --git a/src/x11_platform.h b/src/x11_platform.h
index cdea395746..d67bfb5e92 100644
--- a/src/x11_platform.h
+++ b/src/x11_platform.h
@@ -91,6 +91,9 @@
 #define GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB 0x2098
 #define GLX_CONTEXT_OPENGL_NO_ERROR_ARB 0x31b3
 
+#define STYLE_OVERTHESPOT (XIMPreeditNothing | XIMStatusNothing)
+#define STYLE_ONTHESPOT (XIMPreeditCallbacks | XIMStatusCallbacks)
+
 typedef XID GLXWindow;
 typedef XID GLXDrawable;
 typedef struct __GLXFBConfig* GLXFBConfig;
@@ -165,6 +168,7 @@ typedef Status (* PFN_XSendEvent)(Display*,Window,Bool,long,XEvent*);
 typedef int (* PFN_XSetClassHint)(Display*,Window,XClassHint*);
 typedef XErrorHandler (* PFN_XSetErrorHandler)(XErrorHandler);
 typedef void (* PFN_XSetICFocus)(XIC);
+typedef char* (* PFN_XSetICValues)(XIC,...);
 typedef char* (* PFN_XSetIMValues)(XIM,...);
 typedef int (* PFN_XSetInputFocus)(Display*,Window,int,Time);
 typedef char* (* PFN_XSetLocaleModifiers)(const char*);
@@ -180,6 +184,7 @@ typedef int (* PFN_XUndefineCursor)(Display*,Window);
 typedef int (* PFN_XUngrabPointer)(Display*,Time);
 typedef int (* PFN_XUnmapWindow)(Display*,Window);
 typedef void (* PFN_XUnsetICFocus)(XIC);
+typedef XVaNestedList (* PFN_XVaCreateNestedList)(int,...);
 typedef VisualID (* PFN_XVisualIDFromVisual)(Visual*);
 typedef int (* PFN_XWarpPointer)(Display*,Window,Window,int,int,unsigned int,unsigned int,int,int);
 typedef void (* PFN_XkbFreeKeyboard)(XkbDescPtr,unsigned int,Bool);
@@ -191,6 +196,7 @@ typedef KeySym (* PFN_XkbKeycodeToKeysym)(Display*,KeyCode,int,int);
 typedef Bool (* PFN_XkbQueryExtension)(Display*,int*,int*,int*,int*,int*);
 typedef Bool (* PFN_XkbSelectEventDetails)(Display*,unsigned int,unsigned int,unsigned long,unsigned long);
 typedef Bool (* PFN_XkbSetDetectableAutoRepeat)(Display*,Bool,Bool*);
+typedef char* (* PFN_XmbResetIC)(XIC);
 typedef void (* PFN_XrmDestroyDatabase)(XrmDatabase);
 typedef Bool (* PFN_XrmGetResource)(XrmDatabase,const char*,const char*,char**,XrmValue*);
 typedef XrmDatabase (* PFN_XrmGetStringDatabase)(const char*);
@@ -265,6 +271,7 @@ typedef void (* PFN_Xutf8SetWMProperties)(Display*,Window,const char*,const char
 #define XSetClassHint _glfw.x11.xlib.SetClassHint
 #define XSetErrorHandler _glfw.x11.xlib.SetErrorHandler
 #define XSetICFocus _glfw.x11.xlib.SetICFocus
+#define XSetICValues _glfw.x11.xlib.SetICValues
 #define XSetIMValues _glfw.x11.xlib.SetIMValues
 #define XSetInputFocus _glfw.x11.xlib.SetInputFocus
 #define XSetLocaleModifiers _glfw.x11.xlib.SetLocaleModifiers
@@ -280,6 +287,7 @@ typedef void (* PFN_Xutf8SetWMProperties)(Display*,Window,const char*,const char
 #define XUngrabPointer _glfw.x11.xlib.UngrabPointer
 #define XUnmapWindow _glfw.x11.xlib.UnmapWindow
 #define XUnsetICFocus _glfw.x11.xlib.UnsetICFocus
+#define XVaCreateNestedList _glfw.x11.xlib.VaCreateNestedList
 #define XVisualIDFromVisual _glfw.x11.xlib.VisualIDFromVisual
 #define XWarpPointer _glfw.x11.xlib.WarpPointer
 #define XkbFreeKeyboard _glfw.x11.xkb.FreeKeyboard
@@ -291,6 +299,7 @@ typedef void (* PFN_Xutf8SetWMProperties)(Display*,Window,const char*,const char
 #define XkbQueryExtension _glfw.x11.xkb.QueryExtension
 #define XkbSelectEventDetails _glfw.x11.xkb.SelectEventDetails
 #define XkbSetDetectableAutoRepeat _glfw.x11.xkb.SetDetectableAutoRepeat
+#define XmbResetIC _glfw.x11.xlib.mbResetIC
 #define XrmDestroyDatabase _glfw.x11.xrm.DestroyDatabase
 #define XrmGetResource _glfw.x11.xrm.GetResource
 #define XrmGetStringDatabase _glfw.x11.xrm.GetStringDatabase
@@ -546,6 +555,17 @@ typedef struct _GLFWwindowX11
     // The time of the last KeyPress event per keycode, for discarding
     // duplicate key events generated for some keys by ibus
     Time            keyPressTimes[256];
+
+    // Preedit callbacks
+    XIMCallback preeditStartCallback;
+    XIMCallback preeditDoneCallback;
+    XIMCallback preeditDrawCallback;
+    XIMCallback preeditCaretCallback;
+    XIMCallback statusStartCallback;
+    XIMCallback statusDoneCallback;
+    XIMCallback statusDrawCallback;
+
+    int imeFocus;
 } _GLFWwindowX11;
 
 // X11-specific global data
@@ -566,6 +586,8 @@ typedef struct _GLFWlibraryX11
     XContext        context;
     // XIM input method
     XIM             im;
+    // XIM input method style
+    XIMStyle        imStyle;
     // The previous X error handler, to be restored later
     XErrorHandler   errorHandler;
     // Most recent error code received by X error handler
@@ -711,6 +733,7 @@ typedef struct _GLFWlibraryX11
         PFN_XSetClassHint SetClassHint;
         PFN_XSetErrorHandler SetErrorHandler;
         PFN_XSetICFocus SetICFocus;
+        PFN_XSetICValues SetICValues;
         PFN_XSetIMValues SetIMValues;
         PFN_XSetInputFocus SetInputFocus;
         PFN_XSetLocaleModifiers SetLocaleModifiers;
@@ -726,9 +749,11 @@ typedef struct _GLFWlibraryX11
         PFN_XUngrabPointer UngrabPointer;
         PFN_XUnmapWindow UnmapWindow;
         PFN_XUnsetICFocus UnsetICFocus;
+        PFN_XVaCreateNestedList VaCreateNestedList;
         PFN_XVisualIDFromVisual VisualIDFromVisual;
         PFN_XWarpPointer WarpPointer;
         PFN_XUnregisterIMInstantiateCallback UnregisterIMInstantiateCallback;
+        PFN_XmbResetIC mbResetIC;
         PFN_Xutf8LookupString utf8LookupString;
         PFN_Xutf8SetWMProperties utf8SetWMProperties;
     } xlib;
@@ -938,6 +963,9 @@ void _glfwSetWindowMousePassthroughX11(_GLFWwindow* window, GLFWbool enabled);
 void _glfwSetRawMouseMotionX11(_GLFWwindow *window, GLFWbool enabled);
 GLFWbool _glfwRawMouseMotionSupportedX11(void);
 
+void _glfwSetTouchInputX11(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwTouchInputSupportedX11(void);
+
 void _glfwPollEventsX11(void);
 void _glfwWaitEventsX11(void);
 void _glfwWaitEventsTimeoutX11(double timeout);
@@ -955,6 +983,11 @@ void _glfwSetCursorX11(_GLFWwindow* window, _GLFWcursor* cursor);
 void _glfwSetClipboardStringX11(const char* string);
 const char* _glfwGetClipboardStringX11(void);
 
+void _glfwUpdatePreeditCursorRectangleX11(_GLFWwindow* window);
+void _glfwResetPreeditTextX11(_GLFWwindow* window);
+void _glfwSetIMEStatusX11(_GLFWwindow* window, int active);
+int _glfwGetIMEStatusX11(_GLFWwindow* window);
+
 EGLenum _glfwGetEGLPlatformX11(EGLint** attribs);
 EGLNativeDisplayType _glfwGetEGLNativeDisplayX11(void);
 EGLNativeWindowType _glfwGetEGLNativeWindowX11(_GLFWwindow* window);
diff --git a/src/x11_window.c b/src/x11_window.c
index 7da9b96575..1344ca0410 100644
--- a/src/x11_window.c
+++ b/src/x11_window.c
@@ -366,7 +366,7 @@ static void updateWindowMode(_GLFWwindow* window)
         // Enable compositor bypass
         if (!window->x11.transparent)
         {
-            const unsigned long value = 1;
+            const unsigned long value = _glfw.hints.window.softFullscreen ? 2 : 1;
 
             XChangeProperty(_glfw.x11.display,  window->x11.handle,
                             _glfw.x11.NET_WM_BYPASS_COMPOSITOR, XA_CARDINAL, 32,
@@ -411,29 +411,6 @@ static void updateWindowMode(_GLFWwindow* window)
     }
 }
 
-// Decode a Unicode code point from a UTF-8 stream
-// Based on cutef8 by Jeff Bezanson (Public Domain)
-//
-static uint32_t decodeUTF8(const char** s)
-{
-    uint32_t codepoint = 0, count = 0;
-    static const uint32_t offsets[] =
-    {
-        0x00000000u, 0x00003080u, 0x000e2080u,
-        0x03c82080u, 0xfa082080u, 0x82082080u
-    };
-
-    do
-    {
-        codepoint = (codepoint << 6) + (unsigned char) **s;
-        (*s)++;
-        count++;
-    } while ((**s & 0xc0) == 0x80);
-
-    assert(count <= 6);
-    return codepoint - offsets[count - 1];
-}
-
 // Convert the specified Latin-1 string to UTF-8
 //
 static char* convertLatin1toUTF8(const char* source)
@@ -562,6 +539,235 @@ static void inputContextDestroyCallback(XIC ic, XPointer clientData, XPointer ca
     window->x11.ic = NULL;
 }
 
+// IME Start callback (do nothing)
+//
+static void _ximPreeditStartCallback(XIC xic, XPointer clientData, XPointer callData)
+{
+}
+
+// IME Done callback (do nothing)
+//
+static void _ximPreeditDoneCallback(XIC xic, XPointer clientData, XPointer callData)
+{
+}
+
+// IME Draw callback
+// When using the dafault style: STYLE_OVERTHESPOT, this is not used since applications
+// don't need to display preedit texts.
+//
+static void _ximPreeditDrawCallback(XIC xic, XPointer clientData, XIMPreeditDrawCallbackStruct* callData)
+{
+    _GLFWwindow* window = (_GLFWwindow*) clientData;
+    _GLFWpreedit* preedit = &window->preedit;
+
+    if (!callData->text)
+    {
+        // preedit text is empty
+        preedit->textCount = 0;
+        preedit->blockSizesCount = 0;
+        preedit->focusedBlockIndex = 0;
+        preedit->caretIndex = 0;
+        _glfwInputPreedit(window);
+        return;
+    }
+    else if (callData->text->encoding_is_wchar)
+    {
+        // wchar is not supported
+        return;
+    }
+    else
+    {
+        XIMText* text = callData->text;
+        int textLen = preedit->textCount + text->length - callData->chg_length;
+        int textBufferCount = preedit->textBufferCount;
+        int i, j, rstart, rend;
+        const char* src;
+
+        // realloc preedit text
+        while (textBufferCount < textLen + 1)
+            textBufferCount = (textBufferCount == 0) ? 1 : textBufferCount * 2;
+        if (textBufferCount != preedit->textBufferCount)
+        {
+            unsigned int* preeditText = _glfw_realloc(preedit->text,
+                                                      sizeof(unsigned int) * textBufferCount);
+            if (preeditText == NULL)
+                return;
+
+            preedit->text = preeditText;
+            preedit->textBufferCount = textBufferCount;
+        }
+        preedit->textCount = textLen;
+        preedit->text[textLen] = 0;
+
+        // realloc block sizes
+        if (preedit->blockSizesBufferCount == 0)
+        {
+            preedit->blockSizes = _glfw_calloc(4, sizeof(int));
+            preedit->blockSizesBufferCount = 4;
+        }
+
+        // store preedit text
+        src = text->string.multi_byte;
+        rend = 0;
+        rstart = textLen;
+        for (i = 0, j = callData->chg_first; i < text->length; i++)
+        {
+            XIMFeedback f;
+
+            if (i < callData->chg_first || callData->chg_first + textLen < i)
+                continue;
+
+            preedit->text[j++] = _glfwDecodeUTF8(&src);
+            f = text->feedback[i];
+            if ((f & XIMReverse) || (f & XIMHighlight))
+            {
+                rend = i;
+                if (i < rstart)
+                    rstart = i;
+            }
+        }
+
+        // store block sizes
+        // TODO: It doesn't care callData->chg_first != 0 case although it's quite rare.
+        if (rstart == textLen)
+        {
+            preedit->blockSizesCount = 1;
+            preedit->blockSizes[0] = textLen;
+            preedit->blockSizes[1] = 0;
+            preedit->focusedBlockIndex = 0;
+            preedit->caretIndex = callData->caret;
+            _glfwInputPreedit(window);
+        }
+        else if (rstart == 0)
+        {
+            if (rend == textLen -1)
+            {
+                preedit->blockSizesCount = 1;
+                preedit->blockSizes[0] = textLen;
+                preedit->blockSizes[1] = 0;
+                preedit->focusedBlockIndex = 0;
+                preedit->caretIndex = callData->caret;
+                _glfwInputPreedit(window);
+            }
+            else
+            {
+                preedit->blockSizesCount = 2;
+                preedit->blockSizes[0] = rend + 1;
+                preedit->blockSizes[1] = textLen - rend - 1;
+                preedit->blockSizes[2] = 0;
+                preedit->focusedBlockIndex = 0;
+                preedit->caretIndex = callData->caret;
+                _glfwInputPreedit(window);
+            }
+        }
+        else if (rend == textLen - 1)
+        {
+            preedit->blockSizesCount = 2;
+            preedit->blockSizes[0] = rstart;
+            preedit->blockSizes[1] = textLen - rstart;
+            preedit->blockSizes[2] = 0;
+            preedit->focusedBlockIndex = 1;
+            preedit->caretIndex = callData->caret;
+            _glfwInputPreedit(window);
+        }
+        else
+        {
+            preedit->blockSizesCount = 3;
+            preedit->blockSizes[0] = rstart;
+            preedit->blockSizes[1] = rend - rstart + 1;
+            preedit->blockSizes[2] = textLen - rend - 1;
+            preedit->blockSizes[3] = 0;
+            preedit->focusedBlockIndex = 1;
+            preedit->caretIndex = callData->caret;
+            _glfwInputPreedit(window);
+        }
+    }
+}
+
+// IME Caret callback (do nothing)
+//
+static void _ximPreeditCaretCallback(XIC xic, XPointer clientData, XPointer callData)
+{
+}
+
+// IME Status Start callback
+// When using the dafault style: STYLE_OVERTHESPOT, this is not used and the IME status
+// can not be taken.
+//
+static void _ximStatusStartCallback(XIC xic, XPointer clientData, XPointer callData)
+{
+    _GLFWwindow* window = (_GLFWwindow*) clientData;
+    window->x11.imeFocus = GLFW_TRUE;
+}
+
+// IME Status Done callback
+// When using the dafault style: STYLE_OVERTHESPOT, this is not used and the IME status
+// can not be taken.
+//
+static void _ximStatusDoneCallback(XIC xic, XPointer clientData, XPointer callData)
+{
+    _GLFWwindow* window = (_GLFWwindow*) clientData;
+    window->x11.imeFocus = GLFW_FALSE;
+}
+
+// IME Status Draw callback
+// When using the dafault style: STYLE_OVERTHESPOT, this is not used and the IME status
+// can not be taken.
+//
+static void _ximStatusDrawCallback(XIC xic, XPointer clientData, XIMStatusDrawCallbackStruct* callData)
+{
+    _GLFWwindow* window = (_GLFWwindow*) clientData;
+    _glfwInputIMEStatus(window);
+}
+
+// Create XIM Preedit callback
+// When using the dafault style: STYLE_OVERTHESPOT, this is not used since applications
+// don't need to display preedit texts.
+//
+static XVaNestedList _createXIMPreeditCallbacks(_GLFWwindow* window)
+{
+    window->x11.preeditStartCallback.client_data = (XPointer) window;
+    window->x11.preeditStartCallback.callback = (XIMProc) _ximPreeditStartCallback;
+    window->x11.preeditDoneCallback.client_data = (XPointer) window;
+    window->x11.preeditDoneCallback.callback = (XIMProc) _ximPreeditDoneCallback;
+    window->x11.preeditDrawCallback.client_data = (XPointer) window;
+    window->x11.preeditDrawCallback.callback = (XIMProc) _ximPreeditDrawCallback;
+    window->x11.preeditCaretCallback.client_data = (XPointer) window;
+    window->x11.preeditCaretCallback.callback = (XIMProc) _ximPreeditCaretCallback;
+    return XVaCreateNestedList(0,
+                               XNPreeditStartCallback,
+                               &window->x11.preeditStartCallback.client_data,
+                               XNPreeditDoneCallback,
+                               &window->x11.preeditDoneCallback.client_data,
+                               XNPreeditDrawCallback,
+                               &window->x11.preeditDrawCallback.client_data,
+                               XNPreeditCaretCallback,
+                               &window->x11.preeditCaretCallback.client_data,
+                               NULL);
+}
+
+// Create XIM status callback
+// When using the dafault style: STYLE_OVERTHESPOT, this is not used and the IME status
+// can not be taken.
+//
+static XVaNestedList _createXIMStatusCallbacks(_GLFWwindow* window)
+{
+    window->x11.statusStartCallback.client_data = (XPointer) window;
+    window->x11.statusStartCallback.callback = (XIMProc) _ximStatusStartCallback;
+    window->x11.statusDoneCallback.client_data = (XPointer) window;
+    window->x11.statusDoneCallback.callback = (XIMProc) _ximStatusDoneCallback;
+    window->x11.statusDrawCallback.client_data = (XPointer) window;
+    window->x11.statusDrawCallback.callback = (XIMProc) _ximStatusDrawCallback;
+    return XVaCreateNestedList(0,
+                               XNStatusStartCallback,
+                               &window->x11.statusStartCallback.client_data,
+                               XNStatusDoneCallback,
+                               &window->x11.statusDoneCallback.client_data,
+                               XNStatusDrawCallback,
+                               &window->x11.statusDrawCallback.client_data,
+                               NULL);
+}
+
 // Create the X11 window (and its colormap)
 //
 static GLFWbool createNativeWindow(_GLFWwindow* window,
@@ -1291,7 +1497,7 @@ static void processEvent(XEvent *event)
                         const char* c = chars;
                         chars[count] = '\0';
                         while (c - chars < count)
-                            _glfwInputChar(window, decodeUTF8(&c), mods, plain);
+                            _glfwInputChar(window, _glfwDecodeUTF8(&c), mods, plain);
                     }
 
                     if (chars != buffer)
@@ -1925,16 +2131,55 @@ void _glfwCreateInputContextX11(_GLFWwindow* window)
     callback.callback = (XIMProc) inputContextDestroyCallback;
     callback.client_data = (XPointer) window;
 
-    window->x11.ic = XCreateIC(_glfw.x11.im,
-                               XNInputStyle,
-                               XIMPreeditNothing | XIMStatusNothing,
-                               XNClientWindow,
-                               window->x11.handle,
-                               XNFocusWindow,
-                               window->x11.handle,
-                               XNDestroyCallback,
-                               &callback,
-                               NULL);
+    window->x11.imeFocus = GLFW_FALSE;
+
+    if (_glfw.x11.imStyle == STYLE_ONTHESPOT)
+    {
+        // On X11, on-the-spot style is unstable.
+        // Status callbacks are not called and the preedit cursor position
+        // can not be changed.
+        XVaNestedList preeditList = _createXIMPreeditCallbacks(window);
+        XVaNestedList statusList = _createXIMStatusCallbacks(window);
+
+        window->x11.ic = XCreateIC(_glfw.x11.im,
+                                   XNInputStyle,
+                                   _glfw.x11.imStyle,
+                                   XNClientWindow,
+                                   window->x11.handle,
+                                   XNFocusWindow,
+                                   window->x11.handle,
+                                   XNPreeditAttributes,
+                                   preeditList,
+                                   XNStatusAttributes,
+                                   statusList,
+                                   XNDestroyCallback,
+                                   &callback,
+                                   NULL);
+
+        XFree(preeditList);
+        XFree(statusList);
+    }
+    else if (_glfw.x11.imStyle == STYLE_OVERTHESPOT)
+    {
+        window->x11.ic = XCreateIC(_glfw.x11.im,
+                                   XNInputStyle,
+                                   _glfw.x11.imStyle,
+                                   XNClientWindow,
+                                   window->x11.handle,
+                                   XNFocusWindow,
+                                   window->x11.handle,
+                                   XNDestroyCallback,
+                                   &callback,
+                                   NULL);
+    }
+    else
+    {
+        // (XIMPreeditNothing | XIMStatusNothing) is considered as STYLE_OVERTHESPOT.
+        // So this branch should not be used now.
+        _glfwInputError(GLFW_PLATFORM_ERROR,
+                        "X11: Failed to create input context.");
+        return;
+    }
 
     if (window->x11.ic)
     {
@@ -2779,6 +3024,18 @@ GLFWbool _glfwRawMouseMotionSupportedX11(void)
     return _glfw.x11.xi.available;
 }
 
+
+void _glfwSetTouchInputX11(_GLFWwindow *window, GLFWbool enabled)
+{
+    _glfwInputError(GLFW_FEATURE_UNIMPLEMENTED,
+                    "Cocoa: Touch input not yet implemented");
+}
+
+GLFWbool _glfwTouchInputSupportedX11(void)
+{
+    return GLFW_FALSE;
+}
+
 void _glfwPollEventsX11(void)
 {
     drainEmptyEvents();
@@ -3082,6 +3339,92 @@ const char* _glfwGetClipboardStringX11(void)
     return getSelectionString(_glfw.x11.CLIPBOARD);
 }
 
+// When using STYLE_ONTHESPOT, this doesn't work and the cursor position can't be updated
+//
+void _glfwUpdatePreeditCursorRectangleX11(_GLFWwindow* window)
+{
+    XVaNestedList preedit_attr;
+    XPoint spot;
+    _GLFWpreedit* preedit = &window->preedit;
+
+    if (!window->x11.ic)
+        return;
+
+    spot.x = preedit->cursorPosX + preedit->cursorWidth;
+    spot.y = preedit->cursorPosY + preedit->cursorHeight;
+    preedit_attr = XVaCreateNestedList(0, XNSpotLocation, &spot, NULL);
+    XSetICValues(window->x11.ic, XNPreeditAttributes, preedit_attr, NULL);
+    XFree(preedit_attr);
+}
+
+void _glfwResetPreeditTextX11(_GLFWwindow* window)
+{
+    XIC ic = window->x11.ic;
+    _GLFWpreedit* preedit = &window->preedit;
+
+    /* restore conversion state after resetting ic later */
+    XIMPreeditState preedit_state = XIMPreeditUnKnown;
+    XVaNestedList preedit_attr;
+    char* result;
+
+    if (!ic)
+        return;
+
+    // Can not manage IME in the case of over-the-spot.
+    if (_glfw.x11.imStyle == STYLE_OVERTHESPOT)
+        return;
+
+    if (preedit->textCount == 0)
+        return;
+
+    preedit_attr = XVaCreateNestedList(0, XNPreeditState, &preedit_state, NULL);
+    XGetICValues(ic, XNPreeditAttributes, preedit_attr, NULL);
+    XFree(preedit_attr);
+
+    result = XmbResetIC(ic);
+
+    preedit_attr = XVaCreateNestedList(0, XNPreeditState, preedit_state, NULL);
+    XSetICValues(ic, XNPreeditAttributes, preedit_attr, NULL);
+    XFree(preedit_attr);
+
+    preedit->textCount = 0;
+    preedit->blockSizesCount = 0;
+    preedit->focusedBlockIndex = 0;
+    preedit->caretIndex = 0;
+    _glfwInputPreedit(window);
+
+    XFree (result);
+}
+
+void _glfwSetIMEStatusX11(_GLFWwindow* window, int active)
+{
+    XIC ic = window->x11.ic;
+
+    if (!ic)
+        return;
+
+    // Can not manage IME in the case of over-the-spot.
+    if (_glfw.x11.imStyle == STYLE_OVERTHESPOT)
+        return;
+
+    if (active)
+        XSetICFocus(ic);
+    else
+        XUnsetICFocus(ic);
+}
+
+int _glfwGetIMEStatusX11(_GLFWwindow* window)
+{
+    if (!window->x11.ic)
+        return GLFW_FALSE;
+
+    // Can not manage IME in the case of over-the-spot.
+    if (_glfw.x11.imStyle == STYLE_OVERTHESPOT)
+        return GLFW_FALSE;
+
+    return window->x11.imeFocus;
+}
+
 EGLenum _glfwGetEGLPlatformX11(EGLint** attribs)
 {
     if (_glfw.egl.ANGLE_platform_angle)
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index f81cfeb940..f28a53b67b 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -32,6 +32,7 @@ add_executable(cursor cursor.c ${GLAD_GL})
 add_executable(empty WIN32 MACOSX_BUNDLE empty.c ${TINYCTHREAD} ${GLAD_GL})
 add_executable(gamma WIN32 MACOSX_BUNDLE gamma.c ${GLAD_GL})
 add_executable(icon WIN32 MACOSX_BUNDLE icon.c ${GLAD_GL})
+add_executable(input_text WIN32 MACOSX_BUNDLE input_text.c ${GETOPT} ${GLAD_GL})
 add_executable(inputlag WIN32 MACOSX_BUNDLE inputlag.c ${GETOPT} ${GLAD_GL})
 add_executable(joysticks WIN32 MACOSX_BUNDLE joysticks.c ${GLAD_GL})
 add_executable(tearing WIN32 MACOSX_BUNDLE tearing.c ${GLAD_GL})
@@ -48,8 +49,16 @@ if (RT_LIBRARY)
     target_link_libraries(threads "${RT_LIBRARY}")
 endif()
 
-set(GUI_ONLY_BINARIES empty gamma icon inputlag joysticks tearing threads
-    timeout title triangle-vulkan window)
+if (GLFW_BUILD_X11 OR GLFW_BUILD_WAYLAND)
+    find_package(Fontconfig)
+    if (FONTCONFIG_FOUND)
+        target_compile_definitions(input_text PRIVATE FONTCONFIG_ENABLED)
+        target_link_libraries(input_text fontconfig)
+    endif()
+endif()
+
+set(GUI_ONLY_BINARIES empty gamma icon input_text inputlag joysticks tearing
+    threads timeout title triangle-vulkan window)
 set(CONSOLE_BINARIES allocator clipboard events msaa glfwinfo iconify monitors
     reopen cursor)
 
@@ -70,6 +79,7 @@ endif()
 if (APPLE)
     set_target_properties(empty PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "Empty Event")
     set_target_properties(gamma PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "Gamma")
+    set_target_properties(input_text PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "Input Text")
     set_target_properties(inputlag PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "Input Lag")
     set_target_properties(joysticks PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "Joysticks")
     set_target_properties(tearing PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "Tearing")
diff --git a/tests/events.c b/tests/events.c
index 60d4fc89da..9b01b18df2 100644
--- a/tests/events.c
+++ b/tests/events.c
@@ -52,6 +52,7 @@ typedef struct
     GLFWwindow* window;
     int number;
     int closeable;
+    int touch;
 } Slot;
 
 static void usage(void)
@@ -205,6 +206,8 @@ static const char* get_action_name(int action)
             return "released";
         case GLFW_REPEAT:
             return "repeated";
+        case GLFW_MOVE:
+            return "moved";
     }
 
     return "caused unknown action";
@@ -425,6 +428,15 @@ static void key_callback(GLFWwindow* window, int key, int scancode, int action,
 
     switch (key)
     {
+        case GLFW_KEY_T:
+        {
+            slot->touch = !slot->touch;
+            glfwSetInputMode(window, GLFW_TOUCH, slot->touch);
+
+            printf("(( touch %s ))\n", slot->touch ? "enabled" : "disabled");
+            break;
+        }
+
         case GLFW_KEY_C:
         {
             slot->closeable = !slot->closeable;
@@ -454,6 +466,59 @@ static void char_callback(GLFWwindow* window, unsigned int codepoint)
            counter++, slot->number, glfwGetTime(), codepoint, string);
 }
 
+static void preedit_callback(GLFWwindow* window, int preeditCount,
+                             unsigned int* preeditString, int blockCount,
+                             int* blockSizes, int focusedBlock, int caret)
+{
+    Slot* slot = glfwGetWindowUserPointer(window);
+    int i, blockIndex = -1, remainingBlockSize = 0;
+    int width, height;
+    char encoded[5] = "";
+    size_t encodedCount = 0;
+    printf("%08x to %i at %0.3f: Preedit text ",
+           counter++, slot->number, glfwGetTime());
+    if (preeditCount == 0 || blockCount == 0)
+    {
+        printf("(empty)\n");
+    }
+    else
+    {
+        for (i = 0; i < preeditCount; i++)
+        {
+            if (remainingBlockSize == 0)
+            {
+                if (blockIndex == focusedBlock)
+                    printf("]");
+                blockIndex++;
+                remainingBlockSize = blockSizes[blockIndex];
+                printf("\n   block %d: ", blockIndex);
+                if (blockIndex == focusedBlock)
+                    printf("[");
+            }
+            if (i == caret)
+                printf("|");
+            encodedCount = encode_utf8(encoded, preeditString[i]);
+            encoded[encodedCount] = '\0';
+            printf("%s", encoded);
+            remainingBlockSize--;
+        }
+        if (blockIndex == focusedBlock)
+            printf("]");
+        if (caret == preeditCount)
+            printf("|");
+        printf("\n");
+        glfwGetWindowSize(window, &width, &height);
+        glfwSetPreeditCursorRectangle(window, width/2, height/2, 1, 20);
+    }
+}
+
+static void ime_callback(GLFWwindow* window)
+{
+    Slot* slot = glfwGetWindowUserPointer(window);
+    printf("%08x to %i at %0.3f: IME switched\n",
+           counter++, slot->number, glfwGetTime());
+}
+
 static void drop_callback(GLFWwindow* window, int count, const char* paths[])
 {
     int i;
@@ -493,6 +558,16 @@ static void monitor_callback(GLFWmonitor* monitor, int event)
     }
 }
 
+static void touch_callback(GLFWwindow* window, int touch, int action, double x, double y)
+{
+    printf("%08x at %0.3f: Touch %i %s at position %0.3f %0.3f\n",
+           counter++,
+           glfwGetTime(),
+           touch,
+           get_action_name(action),
+           x, y);
+}
+
 static void joystick_callback(int jid, int event)
 {
     if (event == GLFW_CONNECTED)
@@ -595,6 +670,7 @@ int main(int argc, char** argv)
         char title[128];
 
         slots[i].closeable = GLFW_TRUE;
+        slots[i].touch = GLFW_FALSE;
         slots[i].number = i + 1;
 
         snprintf(title, sizeof(title), "Event Linter (Window %i)", slots[i].number);
@@ -638,7 +714,10 @@ int main(int argc, char** argv)
         glfwSetScrollCallback(slots[i].window, scroll_callback);
         glfwSetKeyCallback(slots[i].window, key_callback);
         glfwSetCharCallback(slots[i].window, char_callback);
+        glfwSetPreeditCallback(slots[i].window, preedit_callback);
+        glfwSetIMEStatusCallback(slots[i].window, ime_callback);
         glfwSetDropCallback(slots[i].window, drop_callback);
+        glfwSetTouchCallback(slots[i].window, touch_callback);
 
         glfwMakeContextCurrent(slots[i].window);
         gladLoadGL(glfwGetProcAddress);
diff --git a/tests/input_text.c b/tests/input_text.c
new file mode 100644
index 0000000000..c46c39a427
--- /dev/null
+++ b/tests/input_text.c
@@ -0,0 +1,839 @@
+//========================================================================
+// Input Test
+// Copyright (c) Camilla Löwy <elmindreda@glfw.org>
+// Copyright (c) Daijiro Fukuda <fukuda@clear-code.com>
+// Copyright (c) Takuro Ashie <ashie@clear-code.com>
+//
+// This software is provided 'as-is', without any express or implied
+// warranty. In no event will the authors be held liable for any damages
+// arising from the use of this software.
+//
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+//
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would
+//    be appreciated but is not required.
+//
+// 2. Altered source versions must be plainly marked as such, and must not
+//    be misrepresented as being the original software.
+//
+// 3. This notice may not be removed or altered from any source
+//    distribution.
+//
+//========================================================================
+//
+// For font handiling, I reffered to https://github.com/Immediate-Mode-UI/Nuklear/wiki/Complete-font-guide.
+// For nuklear handling, I reffered to tests/window.c.
+//
+// Currently, it is made for Japanese input only.
+// You have to select the correct font to display Japanese texts.
+// To handle other languages, you need to add correct ranges to nk_font_config.
+// 
+// On X11 or Wayland, you can choose a font by GUI if "fontconfig" libarary is enabled.
+// 
+// On Win32, "Yu Mincho" is selected by default if it is installed. This font is
+// included in the FOD packages, so it will be installed automatically when you
+// enable Japanese input on your environment, or you can install it by
+// "Manage optional features" in "Apps & features".
+// Refer: https://learn.microsoft.com/en-us/typography/fonts/windows_10_font_list#japanese-supplemental-fonts
+// 
+// On macOS, "Arial Unicode MS" is selected by default if it is installed.
+// I assume that this font is usually installed, but if it is not installed,
+// please install it manually.
+// 
+// You can also specify a TTF filepath and use your own favorite font by setting
+// TTF_FONT_FILEPATH below.
+//
+//========================================================================
+
+// Please comment out and set font filepath here to change default font
+// #define TTF_FONT_FILEPATH ""
+
+#define GLAD_GL_IMPLEMENTATION
+#include <glad/gl.h>
+#define GLFW_INCLUDE_NONE
+#include <GLFW/glfw3.h>
+
+#include <stdarg.h>
+
+#define NK_IMPLEMENTATION
+#define NK_INCLUDE_STANDARD_IO
+#define NK_KEYSTATE_BASED_INPUT
+#define NK_INCLUDE_FIXED_TYPES
+#define NK_INCLUDE_FONT_BAKING
+#define NK_INCLUDE_DEFAULT_FONT
+#define NK_INCLUDE_DEFAULT_ALLOCATOR
+#define NK_INCLUDE_VERTEX_BUFFER_OUTPUT
+#define NK_INCLUDE_STANDARD_VARARGS
+#define NK_BUTTON_TRIGGER_ON_RELEASE
+
+// To increase the number of characters that can be entered at one time
+#define NK_INPUT_MAX 64
+
+#include <nuklear.h>
+
+#define NK_GLFW_GL2_IMPLEMENTATION
+#include <nuklear_glfw_gl2.h>
+
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+
+#include "getopt.h"
+
+#if defined(FONTCONFIG_ENABLED)
+    #include <fontconfig/fontconfig.h>
+#endif
+
+#define MAX_BUFFER_LEN 1024
+
+// https://github.com/Immediate-Mode-UI/Nuklear/wiki/Complete-font-guide
+// https://unicode-table.com
+// To handle other languages, you need to fix these ranges.
+static nk_rune rangesJapan[] = {
+    0x0020, 0x007E, // Basic Latin
+    0x2000, 0x206F, // General Punctuation
+    0x3000, 0x303F, // CJK Symbols and Punctuation
+    0x3041, 0x309F, // Hiragana
+    0x30A0, 0x30FF, // Katakana
+    0x4E00, 0x9FFF, // All Kanji
+    0xFF01, 0xFFEF, // Halfwidth and Fullwidth Forms
+    0
+};
+
+#define MAX_FONTS_LEN 512
+#define MAX_FONT_FAMILY_NAME_LEN 128
+#define MAX_FONT_FILEPATH_LEN 256
+
+static struct nk_font* currentFont;
+static char** fontFamilyNames;
+static char** fontFilePaths;
+static int fontNum = 0;
+static int currentFontIndex = 0;
+
+static int currentIMEStatus = GLFW_FALSE;
+#define MAX_PREEDIT_LEN 128
+static char preeditBuf[MAX_PREEDIT_LEN] = "";
+
+// Assuming that the page-size is 10 at most.
+static char candidateBuf[9][MAX_PREEDIT_LEN];
+static int candidatePageSize = 0;
+
+void usage(void)
+{
+    printf("Usage: input_text [-h] [-s] [-c]\n");
+    printf("Options:\n");
+    printf("  -s Use on-the-spot sytle on X11. This is ignored on other platforms.\n");
+    printf("  -c Use manage-preedit-candidate on Win32. This is ignored on other platforms.\n");
+    printf("  -h Show this help\n");
+}
+
+static size_t encode_utf8(char* s, unsigned int ch)
+{
+    size_t count = 0;
+
+    if (ch < 0x80)
+        s[count++] = (char) ch;
+    else if (ch < 0x800)
+    {
+        s[count++] = (ch >> 6) | 0xc0;
+        s[count++] = (ch & 0x3f) | 0x80;
+    }
+    else if (ch < 0x10000)
+    {
+        s[count++] = (ch >> 12) | 0xe0;
+        s[count++] = ((ch >> 6) & 0x3f) | 0x80;
+        s[count++] = (ch & 0x3f) | 0x80;
+    }
+    else if (ch < 0x110000)
+    {
+        s[count++] = (ch >> 18) | 0xf0;
+        s[count++] = ((ch >> 12) & 0x3f) | 0x80;
+        s[count++] = ((ch >> 6) & 0x3f) | 0x80;
+        s[count++] = (ch & 0x3f) | 0x80;
+    }
+
+    return count;
+}
+
+static int add_font(const char* familyName, const char* ttfFilePath, int checkExistence)
+{
+    if (MAX_FONTS_LEN <= fontNum)
+        return GLFW_FALSE;
+
+    if (MAX_FONT_FAMILY_NAME_LEN <= strlen(familyName) || MAX_FONT_FILEPATH_LEN <= strlen(ttfFilePath))
+        return GLFW_FALSE;
+
+    if (checkExistence)
+    {
+        FILE* fp = fopen(ttfFilePath, "rb");
+        if (!fp)
+            return GLFW_FALSE;
+        fclose(fp);
+    }
+
+    fontFamilyNames[fontNum] = (char*) malloc(1 + strlen(familyName));
+    assert(fontFamilyNames[fontNum]);
+    strcpy(fontFamilyNames[fontNum], familyName);
+
+    fontFilePaths[fontNum] = (char*) malloc(1 + strlen(ttfFilePath));
+    assert(fontFilePaths[fontNum]);
+    strcpy(fontFilePaths[fontNum], ttfFilePath);
+
+    fontNum++;
+
+    return GLFW_TRUE;
+}
+
+static int replace_font(int index, const char* familyName, const char* ttfFilePath, int checkExistence)
+{
+    if (index == 0 || fontNum <= index)
+        return GLFW_FALSE;
+    if (MAX_FONT_FAMILY_NAME_LEN <= strlen(familyName) || MAX_FONT_FILEPATH_LEN <= strlen(ttfFilePath))
+        return GLFW_FALSE;
+
+    if (checkExistence)
+    {
+        FILE* fp = fopen(ttfFilePath, "rb");
+        if (!fp)
+            return GLFW_FALSE;
+        fclose(fp);
+    }
+
+    free(fontFamilyNames[index]);
+    free(fontFilePaths[index]);
+
+    fontFamilyNames[index] = (char*) malloc(1 + strlen(familyName));
+    assert(fontFamilyNames[index]);
+    strcpy(fontFamilyNames[index], familyName);
+
+    fontFilePaths[index] = (char*) malloc(1 + strlen(ttfFilePath));
+    assert(fontFilePaths[index]);
+    strcpy(fontFilePaths[index], ttfFilePath);
+
+    return GLFW_TRUE;
+}
+
+#if defined(TTF_FONT_FILEPATH)
+static int load_custom_font()
+{
+    if (MAX_FONTS_LEN <= fontNum)
+        return GLFW_FALSE;
+    if (!(TTF_FONT_FILEPATH && *TTF_FONT_FILEPATH))
+        return GLFW_FALSE;
+
+    return add_font("Custom", TTF_FONT_FILEPATH, GLFW_TRUE);
+}
+#endif
+
+#if defined(FONTCONFIG_ENABLED)
+static void load_font_list_by_fontconfig()
+{
+    FcConfig* config = FcInitLoadConfigAndFonts();
+    FcFontSet* fontset = FcConfigGetFonts(config, FcSetSystem);
+
+    if (!fontset)
+    {
+        printf("load_font_list_by_fontconfig failed.\n");
+        FcConfigDestroy(config);
+        return;
+    }
+
+    for (int i = 0; i < fontset->nfont; i++)
+    {
+        FcValue fvalue, dvalue;
+        if (FcResultMatch == FcPatternGet(fontset->fonts[i], FC_FAMILY, 0, &fvalue))
+        {
+            if (FcResultMatch == FcPatternGet(fontset->fonts[i], FC_FILE, 0, &dvalue))
+            {
+                const char* familyName = (const char*) fvalue.u.s;
+                const char* filePath = (const char*) dvalue.u.s;
+                int existsFamily = GLFW_FALSE;
+                int existingIndex = 0;
+
+                if (!strstr(filePath, ".ttf"))
+                {
+                    continue;
+                }
+
+                for (int j = 1; j < fontNum; ++j)
+                {
+                    if (strcmp(fontFamilyNames[j], familyName) == 0)
+                    {
+                        existsFamily = GLFW_TRUE;
+                        existingIndex = j;
+                        break;
+                    }
+                }
+
+                if (existsFamily)
+                {
+                    // Prefer "regular" to the others.
+                    if (strstr(filePath, "regular") || strstr(filePath, "Regular"))
+                        replace_font(existingIndex, familyName, filePath, GLFW_FALSE);
+                }
+                else
+                    add_font(familyName, filePath, GLFW_FALSE);
+
+                if (MAX_FONTS_LEN <= fontNum)
+                {
+                    printf("MAX_FONTS_LEN reached. Could not load some fonts.\n");
+                    break;
+                }
+            }
+        }
+    }
+
+    FcConfigDestroy(config);
+}
+#endif
+
+static void load_default_font_for_each_platform()
+{
+    int hasSucceeded = GLFW_FALSE;
+    if (MAX_FONTS_LEN <= fontNum)
+        return;
+
+    if (glfwGetPlatform() == GLFW_PLATFORM_COCOA)
+        hasSucceeded = add_font("Arial Unicode MS", "/Library/Fonts/Arial Unicode.ttf", GLFW_TRUE);
+    else if(glfwGetPlatform() == GLFW_PLATFORM_WIN32)
+    {
+        // Use "Yu Mincho" since it is the only TTF for Japanese in the FOD packages on Windows10 and Windows11.
+        // https://learn.microsoft.com/en-us/typography/fonts/windows_10_font_list#japanese-supplemental-fonts
+        char filepath[MAX_FONT_FILEPATH_LEN];
+        char* winDir = getenv("systemroot");
+        if (winDir)
+            snprintf(filepath, MAX_FONT_FILEPATH_LEN, "%s\\Fonts\\Yumin.ttf", winDir);
+        else
+            strcpy(filepath, "C:\\Windows\\Fonts\\Yumin.ttf");
+        hasSucceeded = add_font("Yu Mincho Regular", filepath, GLFW_TRUE);
+    }
+
+    if (hasSucceeded)
+        currentFontIndex = fontNum - 1;
+}
+
+static void init_font_list()
+{
+    int useCustomFont = GLFW_FALSE;
+    int customFontIndex = 0;
+
+    fontFamilyNames = (char**) malloc(sizeof(char*) * MAX_FONTS_LEN);
+    assert(fontFamilyNames);
+    fontFilePaths = (char**) malloc(sizeof(char*) * MAX_FONTS_LEN);
+    assert(fontFilePaths);
+
+    fontFamilyNames[0] = "GLFW default";
+    fontFilePaths[0] = "";
+    fontNum++;
+
+#if defined(TTF_FONT_FILEPATH)
+    useCustomFont = load_custom_font();
+    if (useCustomFont)
+        customFontIndex = fontNum - 1;
+#endif
+
+    load_default_font_for_each_platform();
+
+#if defined(FONTCONFIG_ENABLED)
+    load_font_list_by_fontconfig();
+#endif
+
+    if (useCustomFont)
+        currentFontIndex = customFontIndex;
+}
+
+static void deinit_font_list()
+{
+    for (int i = 1; i < fontNum; ++i)
+    {
+        free(fontFamilyNames[i]);
+        free(fontFilePaths[i]);
+    }
+
+    free(fontFamilyNames);
+    free(fontFilePaths);
+}
+
+// https://github.com/Immediate-Mode-UI/Nuklear/wiki/Complete-font-guide
+static void update_font(struct nk_context* nk, float height)
+{
+    struct nk_font_atlas* atlas;
+
+    nk_glfw3_font_stash_begin(&atlas);
+
+    if (currentFontIndex == 0)
+    {
+        currentFont = nk_font_atlas_add_default(atlas, height, 0);
+    }
+    else
+    {
+        struct nk_font* new_font;
+        struct nk_font_config cfg;
+        cfg = nk_font_config(0);
+        cfg.range = rangesJapan;
+        cfg.oversample_h = 1;
+        cfg.oversample_v = 1;
+        cfg.pixel_snap = true;
+
+        new_font = nk_font_atlas_add_from_file(atlas, fontFilePaths[currentFontIndex], height, &cfg);
+        if (new_font)
+        {
+            currentFont = new_font;
+            printf("Succeeded to load font file: %s\n", fontFilePaths[currentFontIndex]);
+        }
+        else
+            printf("Failed to load font file: %s\n", fontFilePaths[currentFontIndex]);
+    }
+
+    nk_glfw3_font_stash_end();
+    nk_style_set_font(nk, &currentFont->handle);
+}
+
+static void set_menu_buttons(GLFWwindow* window, struct nk_context* nk, int height)
+{
+    static int windowedX, windowedY, windowedWidth, windowedHeight;
+
+    nk_layout_row_dynamic(nk, height, 2);
+    if (nk_button_label(nk, "Toggle Fullscreen"))
+    {
+        if (glfwGetWindowMonitor(window))
+        {
+            glfwSetWindowMonitor(window, NULL,
+                                 windowedX, windowedY,
+                                 windowedWidth, windowedHeight, 0);
+        }
+        else
+        {
+            GLFWmonitor* monitor = glfwGetPrimaryMonitor();
+            const GLFWvidmode* mode = glfwGetVideoMode(monitor);
+            glfwGetWindowPos(window, &windowedX, &windowedY);
+            glfwGetWindowSize(window, &windowedWidth, &windowedHeight);
+            glfwSetWindowMonitor(window, monitor,
+                                 0, 0, mode->width, mode->height,
+                                 mode->refreshRate);
+        }
+    }
+
+    {
+        int auto_iconify = glfwGetWindowAttrib(window, GLFW_AUTO_ICONIFY);
+        if (nk_checkbox_label(nk, "Auto Iconify", &auto_iconify))
+            glfwSetWindowAttrib(window, GLFW_AUTO_ICONIFY, auto_iconify);
+    }
+}
+
+static int set_font_selecter(GLFWwindow* window, struct nk_context* nk, int height, int fontHeight)
+{
+    int newSelectedIndex;
+
+    nk_layout_row_begin(nk, NK_DYNAMIC, height, 2);
+
+    nk_layout_row_push(nk, 1.f / 3.f);
+    nk_label(nk, "Font", NK_TEXT_LEFT);
+
+    nk_layout_row_push(nk, 2.f / 3.f);
+    newSelectedIndex = nk_combo(nk, (const char**) fontFamilyNames, fontNum, currentFontIndex, fontHeight, nk_vec2(300, 400));
+
+    nk_layout_row_end(nk);
+
+    if (newSelectedIndex == currentFontIndex)
+        return GLFW_FALSE;
+
+    currentFontIndex = newSelectedIndex;
+    return GLFW_TRUE;
+}
+
+static void set_ime_buttons(GLFWwindow* window, struct nk_context* nk, int height)
+{
+    nk_layout_row_dynamic(nk, height, 2);
+
+    if (nk_button_label(nk, "Toggle IME status"))
+    {
+        glfwSetInputMode(window, GLFW_IME, !currentIMEStatus);
+    }
+
+    if (nk_button_label(nk, "Reset preedit text"))
+    {
+        glfwResetPreeditText(window);
+    }
+}
+
+static void set_preedit_cursor_edit(GLFWwindow* window, struct nk_context* nk, int height, int* isAutoUpdating)
+{
+    static int lastX = -1, lastY = -1, lastW = -1, lastH = -1;
+    static char xBuf[12] = "", yBuf[12] = "", wBuf[12] = "", hBuf[12] = "";
+
+    const nk_flags flags = NK_EDIT_FIELD |
+                           NK_EDIT_SIG_ENTER |
+                           NK_EDIT_GOTO_END_ON_ACTIVATE;
+    nk_flags events;
+    int x, y, w, h;
+
+    glfwGetPreeditCursorRectangle(window, &x, &y, &w, &h);
+
+    if (x != lastX)
+        sprintf(xBuf, "%i", x);
+    if (y != lastY)
+        sprintf(yBuf, "%i", y);
+    if (w != lastW)
+        sprintf(wBuf, "%i", w);
+    if (h != lastH)
+        sprintf(hBuf, "%i", h);
+
+    nk_layout_row_begin(nk, NK_DYNAMIC, height, 5);
+
+    nk_layout_row_push(nk, 4.f / 9.f);
+    nk_label(nk, "Preedit cursor (x,y,w,h)", NK_TEXT_LEFT);
+
+    nk_layout_row_push(nk, 1.f / 9.f);
+    events = nk_edit_string_zero_terminated(nk, flags, xBuf,
+                                            sizeof(xBuf),
+                                            nk_filter_decimal);
+    if (events & NK_EDIT_COMMITED)
+    {
+        x = atoi(xBuf);
+        *isAutoUpdating = GLFW_FALSE;
+        glfwSetPreeditCursorRectangle(window, x, y, w, h);
+    }
+    else if (events & NK_EDIT_DEACTIVATED)
+        sprintf(xBuf, "%i", x);
+
+    nk_layout_row_push(nk, 1.f / 9.f);
+    events = nk_edit_string_zero_terminated(nk, flags, yBuf,
+                                            sizeof(yBuf),
+                                            nk_filter_decimal);
+    if (events & NK_EDIT_COMMITED)
+    {
+        y = atoi(yBuf);
+        *isAutoUpdating = GLFW_FALSE;
+        glfwSetPreeditCursorRectangle(window, x, y, w, h);
+    }
+    else if (events & NK_EDIT_DEACTIVATED)
+        sprintf(yBuf, "%i", y);
+
+    nk_layout_row_push(nk, 1.f / 9.f);
+    events = nk_edit_string_zero_terminated(nk, flags, wBuf,
+                                            sizeof(wBuf),
+                                            nk_filter_decimal);
+    if (events & NK_EDIT_COMMITED)
+    {
+        w = atoi(wBuf);
+        *isAutoUpdating = GLFW_FALSE;
+        glfwSetPreeditCursorRectangle(window, x, y, w, h);
+    }
+    else if (events & NK_EDIT_DEACTIVATED)
+        sprintf(wBuf, "%i", w);
+
+    nk_layout_row_push(nk, 1.f / 9.f);
+    events = nk_edit_string_zero_terminated(nk, flags, hBuf,
+                                            sizeof(hBuf),
+                                            nk_filter_decimal);
+    if (events & NK_EDIT_COMMITED)
+    {
+        h = atoi(hBuf);
+        *isAutoUpdating = GLFW_FALSE;
+        glfwSetPreeditCursorRectangle(window, x, y, w, h);
+    }
+    else if (events & NK_EDIT_DEACTIVATED)
+        sprintf(hBuf, "%i", h);
+
+    nk_layout_row_push(nk, 1.f / 9.f);
+    nk_checkbox_label(nk, "Auto", isAutoUpdating);
+
+    nk_layout_row_end(nk);
+
+    lastX = x;
+    lastY = y;
+    lastW = w;
+    lastH = h;
+}
+
+static void set_ime_stauts_labels(GLFWwindow* window, struct nk_context* nk, int height)
+{
+    nk_layout_row_dynamic(nk, height, 1);
+    nk_value_bool(nk, "IME status", currentIMEStatus);
+}
+
+static void set_preedit_labels(GLFWwindow* window, struct nk_context* nk, int height)
+{
+    nk_layout_row_begin(nk, NK_DYNAMIC, height, 5);
+
+    nk_layout_row_push(nk, 1.f / 3.f);
+    nk_label(nk, "Preedit info:", NK_TEXT_LEFT);
+
+    nk_layout_row_push(nk, 2.f / 3.f);
+    nk_label(nk, (const char*) preeditBuf, NK_TEXT_LEFT);
+
+    nk_layout_row_end(nk);
+}
+
+static void set_candidate_labels(GLFWwindow* window, struct nk_context* nk)
+{
+    for (int i = 0; i < 5; ++i)
+    {
+        nk_layout_row_begin(nk, NK_DYNAMIC, 30, 3);
+        nk_layout_row_push(nk, 1.f / 3.f);
+        if (i == 0)
+            nk_label(nk, "Candidates:", NK_TEXT_LEFT);
+        else
+            nk_label(nk, "", NK_TEXT_LEFT);
+        nk_layout_row_push(nk, 1.f / 3.f);
+        if (candidatePageSize > i)
+            nk_label(nk, (const char*) candidateBuf[i], NK_TEXT_LEFT);
+        nk_layout_row_push(nk, 1.f / 3.f);
+        if (candidatePageSize > i + 5)
+            nk_label(nk, (const char*) candidateBuf[i + 5], NK_TEXT_LEFT);
+        nk_layout_row_end(nk);
+    }
+}
+
+// If it is possible to take the text-cursor position calculated in `nk_do_edit` function in `deps/nuklear.h`,
+// we can set preedit-cursor position more easily.
+// However, there doesn't seem to be a way to do that, so this does a simplified calculation only for the end
+// of the text. (Can not trace the cursor movement)
+static void update_cursor_pos(GLFWwindow* window, struct nk_context* nk, struct nk_user_font* f,
+                              char* boxBuffer, int boxLen, int boxX, int boxY)
+{
+    float lineWidth = 0;
+    int totalLines = 1;
+
+    const char* text;
+    int textPos = 0;
+
+    struct nk_str nkString;
+    nk_str_init_fixed(&nkString, boxBuffer, (nk_size) MAX_BUFFER_LEN);
+    nkString.buffer.allocated = (nk_size) boxLen;
+    nkString.len = nk_utf_len(boxBuffer, boxLen);
+
+    text = nk_str_get_const(&nkString);
+
+    while (textPos < boxLen)
+    {
+        nk_rune unicode = 0;
+        int remainedBoxLen = boxLen - textPos;
+        int nextGlyphSize = nk_utf_decode(text + textPos, &unicode, remainedBoxLen);
+        if (!nextGlyphSize)
+            break;
+
+        if (unicode == '\n')
+        {
+            textPos++;
+            totalLines++;
+            lineWidth = 0;
+            continue;
+        }
+
+        textPos += nextGlyphSize;
+        lineWidth += f->width(f->userdata, f->height, text + textPos, nextGlyphSize);
+    }
+
+    {
+        int lineHeight = f->height + nk->style.edit.row_padding;
+
+        int cursorPosX = boxX + lineWidth;
+        int cursorPosY = boxY + lineHeight * (totalLines - 1);
+        int cursorHeight = lineHeight;
+        int cursorWidth;
+
+        // Keep the value of width since it doesn't need to be updated.
+        glfwGetPreeditCursorRectangle(window, NULL, NULL, &cursorWidth, NULL);
+
+        glfwSetPreeditCursorRectangle(window, cursorPosX, cursorPosY, cursorWidth, cursorHeight);
+    }
+}
+
+static void ime_callback(GLFWwindow* window)
+{
+    currentIMEStatus = glfwGetInputMode(window, GLFW_IME);
+    printf("IME switched: %s\n", currentIMEStatus ? "ON" : "OFF");
+}
+
+static void preedit_callback(GLFWwindow* window, int preeditCount,
+                             unsigned int* preeditString, int blockCount,
+                             int* blockSizes, int focusedBlock, int caret)
+{
+    int blockIndex = -1, remainingBlockSize = 0;
+    if (preeditCount == 0 || blockCount == 0)
+    {
+        strcpy(preeditBuf, "(empty)");
+        return;
+    }
+
+    strcpy(preeditBuf, "");
+
+    for (int i = 0; i < preeditCount; i++)
+    {
+        char encoded[5] = "";
+        size_t encodedCount = 0;
+
+        if (i == caret)
+        {
+            if (strlen(preeditBuf) + strlen("|") < MAX_PREEDIT_LEN)
+                strcat(preeditBuf, "|");
+        }
+        if (remainingBlockSize == 0)
+        {
+            if (blockIndex == focusedBlock)
+            {
+                if (strlen(preeditBuf) + strlen("]") < MAX_PREEDIT_LEN)
+                    strcat(preeditBuf, "]");
+            }
+            blockIndex++;
+            remainingBlockSize = blockSizes[blockIndex];
+            if (blockIndex == focusedBlock)
+            {
+                if (strlen(preeditBuf) + strlen("[") < MAX_PREEDIT_LEN)
+                    strcat(preeditBuf, "[");
+            }
+        }
+        encodedCount = encode_utf8(encoded, preeditString[i]);
+        encoded[encodedCount] = '\0';
+        if (strlen(preeditBuf) + strlen(encoded) < MAX_PREEDIT_LEN)
+            strcat(preeditBuf, encoded);
+        remainingBlockSize--;
+    }
+    if (blockIndex == focusedBlock)
+    {
+        if (strlen(preeditBuf) + strlen("]") < MAX_PREEDIT_LEN)
+            strcat(preeditBuf, "]");
+    }
+    if (caret == preeditCount)
+    {
+        if (strlen(preeditBuf) + strlen("|") < MAX_PREEDIT_LEN)
+            strcat(preeditBuf, "|");
+    }
+}
+
+static void candidate_callback(GLFWwindow* window, int candidates_count,
+                               int selected_index, int page_start, int page_size)
+{
+    int i, j;
+    candidatePageSize = page_size;
+    for (i = 0; i < page_size; ++i)
+    {
+        int index = i + page_start;
+        int textCount;
+        unsigned int* text = glfwGetPreeditCandidate(window, index, &textCount);
+        if (index == selected_index)
+            strcpy(candidateBuf[i], "> ");
+        else
+            strcpy(candidateBuf[i], "");
+        for (j = 0; j < textCount; ++j)
+        {
+            char encoded[5] = "";
+            encode_utf8(encoded, text[j]);
+            if (strlen(candidateBuf[i]) + strlen(encoded) < MAX_PREEDIT_LEN)
+                strcat(candidateBuf[i], encoded);
+        }
+    }
+}
+
+int main(int argc, char** argv)
+{
+    GLFWwindow* window;
+    struct nk_context* nk;
+    int width, height;
+    char boxBuffer[MAX_BUFFER_LEN] = "Input text here.";
+    int boxLen = strlen(boxBuffer);
+    int isAutoUpdatingCursorPosEnabled = GLFW_TRUE;
+    int managePreeditCandidate = GLFW_FALSE;
+    int ch;
+
+    while ((ch = getopt(argc, argv, "hsc")) != -1)
+    {
+        switch (ch)
+        {
+            case 'h':
+                usage();
+                exit(EXIT_SUCCESS);
+
+            case 's':
+                glfwInitHint(GLFW_X11_ONTHESPOT, GLFW_TRUE);
+                break;
+
+            case 'c':
+                glfwInitHint(GLFW_MANAGE_PREEDIT_CANDIDATE, GLFW_TRUE);
+                managePreeditCandidate = GLFW_TRUE;
+                break;
+        }
+    }
+
+    if (!glfwInit())
+        exit(EXIT_FAILURE);
+
+    glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);
+    glfwWindowHint(GLFW_WIN32_KEYBOARD_MENU, GLFW_TRUE);
+    glfwWindowHint(GLFW_SOFT_FULLSCREEN, GLFW_TRUE);
+    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
+    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
+
+    window = glfwCreateWindow(600, 600, "Input Text", NULL, NULL);
+    if (!window)
+    {
+        glfwTerminate();
+        exit(EXIT_FAILURE);
+    }
+
+    currentIMEStatus = glfwGetInputMode(window, GLFW_IME);
+    glfwSetPreeditCursorRectangle(window, 0, 0, 1, 1);
+    glfwSetIMEStatusCallback(window, ime_callback);
+    glfwSetPreeditCallback(window, preedit_callback);
+    glfwSetPreeditCandidateCallback(window, candidate_callback);
+
+    glfwMakeContextCurrent(window);
+    gladLoadGL(glfwGetProcAddress);
+    glfwSwapInterval(0);
+
+    nk = nk_glfw3_init(window, NK_GLFW3_INSTALL_CALLBACKS);
+    init_font_list();
+    update_font(nk, 18);
+
+    while (!glfwWindowShouldClose(window))
+    {
+        struct nk_rect area;
+
+        glfwGetWindowSize(window, &width, &height);
+
+        area = nk_rect(0.f, 0.f, (float) width, (float) height);
+        nk_window_set_bounds(nk, "main", area);
+
+        nk_glfw3_new_frame();
+        if (nk_begin(nk, "main", area, 0))
+        {
+            set_menu_buttons(window, nk, 30);
+            if (set_font_selecter(window, nk, 30, 18))
+                update_font(nk, 18);
+            set_ime_buttons(window, nk, 30);
+            set_preedit_cursor_edit(window, nk, 30, &isAutoUpdatingCursorPosEnabled);
+            set_ime_stauts_labels(window, nk, 30);
+            set_preedit_labels(window, nk, 30);
+            if (managePreeditCandidate)
+                set_candidate_labels(window, nk);
+
+            nk_layout_row_dynamic(nk, height - 250, 1);
+            nk_edit_string(nk, NK_EDIT_BOX, boxBuffer, &boxLen, MAX_BUFFER_LEN, nk_filter_default);
+        }
+        nk_end(nk);
+
+        glClear(GL_COLOR_BUFFER_BIT);
+        nk_glfw3_render(NK_ANTI_ALIASING_ON);
+        glfwSwapBuffers(window);
+
+        if (isAutoUpdatingCursorPosEnabled)
+            // I don't know how to get the layout info of `nk_edit_string`.
+            update_cursor_pos(window, nk, &currentFont->handle, boxBuffer, boxLen, 10,
+                              managePreeditCandidate ? 385 : 220);
+
+        glfwWaitEvents();
+    }
+
+    deinit_font_list();
+
+    nk_glfw3_shutdown();
+    glfwTerminate();
+    exit(EXIT_SUCCESS);
+}
